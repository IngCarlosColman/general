    Tablas de la Guía Telefónica Global (Solo Lectura)
    Estas tablas son la fuente de datos principal y no pueden ser modificadas directamente por los usuarios desde su agenda personal.
    general: La tabla que contiene la información básica y global de todas las personas (nombres, apellidos, cédula).
    telefonos: Almacena los números de teléfono principales, asociados a los registros de la tabla general.
    Tablas de la Agenda Personal (Por Usuario)
    Estas tablas son el espacio personal de cada usuario. Los cambios que se hagan aquí solo afectarán a su propia agenda, dejando intacta la información de la guía telefónica global.
    user_agendas: La tabla central que conecta al user_id con el contacto (a través de la contact_cedula). Es la que define qué contactos de la guía telefónica pertenecen a la agenda de cada usuario.
    user_nombres: Guarda los nombres personalizados que cada usuario le asigne a un contacto.
    user_telefonos: Permite a cada usuario agregar y gestionar sus propios números de teléfono para un contacto, de forma independiente de los números globales.
    contact_details: Almacena los detalles adicionales que el usuario personaliza, como el cargo, la empresa o el perfil de LinkedIn.
    contact_notes: Un historial detallado de las notas o interacciones que el usuario tiene con un contacto.
    follow_up_events: Se utiliza para los eventos de seguimiento y recordatorios (fecha, título, etc.) que cada usuario crea para sus contactos.
    categorias: Contiene los nombres de las categorías que el usuario puede crear (por ejemplo, "Negocios", "Familia").
    user_agenda_categorias: Conecta a un contacto de la agenda de un usuario con una o varias categorías.
    ======================
    datos_ap-# \d+ general;
                                                                    Table "public.general"
        Column     |           Type           | Collation | Nullable |               Default               | Storage  | Compression | Stats target | Description
    ---------------+--------------------------+-----------+----------+-------------------------------------+----------+-------------+--------------+-------------
    id            | integer                  |           | not null | nextval('general_id_seq'::regclass) | plain    |             |              |
    nombres       | text                     |           |          |                                     | extended |             |              |
    apellidos     | text                     |           |          |                                     | extended |             |              |
    completo      | text                     |           |          |                                     | extended |             |              |
    cedula        | text                     |           |          |                                     | extended |             |              |
    search_vector | tsvector                 |           |          |                                     | extended |             |              |
    created_at    | timestamp with time zone |           | not null | now()                               | plain    |             |              |
    created_by    | integer                  |           |          |                                     | plain    |             |              |
    updated_at    | timestamp with time zone |           |          |                                     | plain    |             |              |
    updated_by    | integer                  |           |          |                                     | plain    |             |              |
    Indexes:
        "general_pkey" PRIMARY KEY, btree (id)
        "idx_general_apellidos" btree (apellidos)
        "idx_general_cedula" btree (cedula)
        "idx_general_nombres" btree (nombres)
        "idx_general_search_vector" gin (search_vector)
        "unique_cedula_constraint" UNIQUE CONSTRAINT, btree (cedula)
    Foreign-key constraints:
        "fk_general_created_by" FOREIGN KEY (created_by) REFERENCES users(id)
        "fk_general_updated_by" FOREIGN KEY (updated_by) REFERENCES users(id)
    Referenced by:
        TABLE "abogados" CONSTRAINT "fk_abogados_general" FOREIGN KEY (cedula) REFERENCES general(cedula) ON UPDATE CASCADE ON DELETE SET NULL
        TABLE "contact_details" CONSTRAINT "fk_cedula_contact_general" FOREIGN KEY (cedula) REFERENCES general(cedula) ON UPDATE CASCADE ON DELETE CASCADE
        TABLE "despachantes" CONSTRAINT "fk_despachantes_general" FOREIGN KEY (cedula) REFERENCES general(cedula) ON UPDATE CASCADE ON DELETE SET NULL
        TABLE "docentes" CONSTRAINT "fk_docentes_general" FOREIGN KEY (cedula) REFERENCES general(cedula) ON UPDATE CASCADE ON DELETE SET NULL
        TABLE "func_bnf" CONSTRAINT "fk_func_bnf_general" FOREIGN KEY (cedula) REFERENCES general(cedula) ON UPDATE CASCADE ON DELETE SET NULL
        TABLE "funcpublic" CONSTRAINT "fk_funcpublic_general" FOREIGN KEY (cedula) REFERENCES general(cedula) ON UPDATE CASCADE ON DELETE SET NULL
        TABLE "itaipu" CONSTRAINT "fk_itaipu_general" FOREIGN KEY (cedula) REFERENCES general(cedula) ON UPDATE CASCADE ON DELETE SET NULL
        TABLE "user_agendas" CONSTRAINT "fk_user_agenda_contact" FOREIGN KEY (contact_cedula) REFERENCES general(cedula) ON UPDATE CASCADE ON DELETE CASCADE
        TABLE "yacyreta" CONSTRAINT "fk_yacyreta_general" FOREIGN KEY (cedula) REFERENCES general(cedula) ON UPDATE CASCADE ON DELETE CASCADE
        TABLE "telefonos" CONSTRAINT "telefonos_cedula_persona_fkey" FOREIGN KEY (cedula_persona) REFERENCES general(cedula) ON DELETE CASCADE
        TABLE "telefonos_historial" CONSTRAINT "telefonos_historial_cedula_persona_fkey" FOREIGN KEY (cedula_persona) REFERENCES general(cedula) ON DELETE CASCADE
    Triggers:
        general_audit_trigger BEFORE UPDATE ON general FOR EACH ROW EXECUTE FUNCTION update_audit_fields()
        general_search_vector_update BEFORE INSERT OR UPDATE ON general FOR EACH ROW EXECUTE FUNCTION update_general_search_vector()
        trg_update_search_vector BEFORE INSERT OR UPDATE ON general FOR EACH ROW EXECUTE FUNCTION update_general_search_vector()
    Access method: heap
    datos_ap-# \d+ telefonos;
                                                            Table "public.telefonos"
        Column     |  Type   | Collation | Nullable |                Default                | Storage  | Compression | Stats target | Description
    ----------------+---------+-----------+----------+---------------------------------------+----------+-------------+--------------+-------------
    id             | integer |           | not null | nextval('telefonos_id_seq'::regclass) | plain    |             |              |
    cedula_persona | text    |           |          |                                       | extended |             |              |
    numero         | text    |           | not null |                                       | extended |             |              |
    tipo           | text    |           | not null |                                       | extended |             |              |
    id_usuario     | integer |           |          |                                       | plain    |             |              |
    Indexes:
        "telefonos_pkey" PRIMARY KEY, btree (id)
        "idx_telefonos_cedula" btree (cedula_persona)
        "idx_telefonos_numero" btree (numero)
    Foreign-key constraints:
        "telefonos_cedula_persona_fkey" FOREIGN KEY (cedula_persona) REFERENCES general(cedula) ON DELETE CASCADE
    Access method: heap
    datos_ap-# \d+ user_agendas;
                                                            Table "public.user_agendas"
        Column     |           Type           | Collation | Nullable |      Default      | Storage  | Compression | Stats target | Description
    ----------------+--------------------------+-----------+----------+-------------------+----------+-------------+--------------+-------------
    user_id        | integer                  |           | not null |                   | plain    |             |              |
    contact_cedula | text                     |           | not null |                   | extended |             |              |
    created_at     | timestamp with time zone |           |          | CURRENT_TIMESTAMP | plain    |             |              |
    updated_at     | timestamp with time zone |           |          | CURRENT_TIMESTAMP | plain    |             |              |
    tipo_relacion  | character varying(50)    |           |          |                   | extended |             |              |
    Indexes:
        "user_agendas_pkey" PRIMARY KEY, btree (user_id, contact_cedula)
        "idx_user_agendas_tipo_relacion" btree (tipo_relacion)
    Foreign-key constraints:
        "fk_user_agenda_contact" FOREIGN KEY (contact_cedula) REFERENCES general(cedula) ON UPDATE CASCADE ON DELETE CASCADE
        "fk_user_agenda_user" FOREIGN KEY (user_id) REFERENCES users(id) ON UPDATE CASCADE ON DELETE CASCADE
    Referenced by:
        TABLE "contact_notes" CONSTRAINT "contact_notes_user_id_contact_cedula_fkey" FOREIGN KEY (user_id, contact_cedula) REFERENCES user_agendas(user_id, contact_cedula) ON DELETE CASCADE
        TABLE "contact_notes" CONSTRAINT "fk_contact_notes" FOREIGN KEY (user_id, contact_cedula) REFERENCES user_agendas(user_id, contact_cedula) ON DELETE CASCADE
        TABLE "follow_up_events" CONSTRAINT "fk_follow_up_event_contact" FOREIGN KEY (user_id, contact_cedula) REFERENCES user_agendas(user_id, contact_cedula) ON DELETE CASCADE
        TABLE "user_agenda_categorias" CONSTRAINT "fk_user_agenda_categorias_user" FOREIGN KEY (user_id, contact_cedula) REFERENCES user_agendas(user_id, contact_cedula) ON DELETE CASCADE
        TABLE "contact_details" CONSTRAINT "fk_user_contact_details" FOREIGN KEY (user_id, cedula) REFERENCES user_agendas(user_id, contact_cedula) ON DELETE CASCADE
        TABLE "user_nombres" CONSTRAINT "fk_user_nombres" FOREIGN KEY (user_id, contact_cedula) REFERENCES user_agendas(user_id, contact_cedula) ON DELETE CASCADE
        TABLE "user_telefonos" CONSTRAINT "fk_user_telefonos" FOREIGN KEY (user_id, contact_cedula) REFERENCES user_agendas(user_id, contact_cedula) ON DELETE CASCADE
        TABLE "user_agenda_categorias" CONSTRAINT "user_agenda_categorias_user_id_contact_cedula_fkey" FOREIGN KEY (user_id, contact_cedula) REFERENCES user_agendas(user_id, contact_cedula) ON DELETE CASCADE
        TABLE "user_nombres" CONSTRAINT "user_nombres_user_id_contact_cedula_fkey" FOREIGN KEY (user_id, contact_cedula) REFERENCES user_agendas(user_id, contact_cedula) ON DELETE CASCADE
        TABLE "user_telefonos" CONSTRAINT "user_telefonos_user_id_contact_cedula_fkey" FOREIGN KEY (user_id, contact_cedula) REFERENCES user_agendas(user_id, contact_cedula) ON DELETE CASCADE
    Access method: heap
    datos_ap-# \d+ user_nombres;
                                                        Table "public.user_nombres"
            Column        |          Type          | Collation | Nullable | Default | Storage  | Compression | Stats target | Description
    ----------------------+------------------------+-----------+----------+---------+----------+-------------+--------------+-------------
    user_id              | integer                |           | not null |         | plain    |             |              |
    contact_cedula       | character varying(255) |           | not null |         | extended |             |              |
    nombre_personalizado | text                   |           | not null |         | extended |             |              |
    Indexes:
        "user_nombres_pkey" PRIMARY KEY, btree (user_id, contact_cedula)
    Foreign-key constraints:
        "fk_user_nombres" FOREIGN KEY (user_id, contact_cedula) REFERENCES user_agendas(user_id, contact_cedula) ON DELETE CASCADE
        "user_nombres_user_id_contact_cedula_fkey" FOREIGN KEY (user_id, contact_cedula) REFERENCES user_agendas(user_id, contact_cedula) ON DELETE CASCADE
    Access method: heap
    datos_ap-# \d+ user_telefonos;
                                                                    Table "public.user_telefonos"
        Column     |          Type          | Collation | Nullable |                  Default                   | Storage  | Compression | Stats target | Description
    ----------------+------------------------+-----------+----------+--------------------------------------------+----------+-------------+--------------+-------------
    id             | integer                |           | not null | nextval('user_telefonos_id_seq'::regclass) | plain    |             |              |
    user_id        | integer                |           | not null |                                            | plain    |             |              |
    contact_cedula | character varying(255) |           | not null |                                            | extended |             |              |
    numero         | text                   |           | not null |                                            | extended |             |              |
    tipo           | text                   |           |          |                                            | extended |             |              |
    Indexes:
        "user_telefonos_pkey" PRIMARY KEY, btree (id)
    Foreign-key constraints:
        "fk_user_telefonos" FOREIGN KEY (user_id, contact_cedula) REFERENCES user_agendas(user_id, contact_cedula) ON DELETE CASCADE
        "user_telefonos_user_id_contact_cedula_fkey" FOREIGN KEY (user_id, contact_cedula) REFERENCES user_agendas(user_id, contact_cedula) ON DELETE CASCADE
    Access method: heap
    datos_ap-# \d+ contact_details;
                                                            Table "public.contact_details"
        Column      |           Type           | Collation | Nullable |      Default      | Storage  | Compression | Stats target | Description
    ------------------+--------------------------+-----------+----------+-------------------+----------+-------------+--------------+-------------
    cedula           | character varying(255)   |           | not null |                   | extended |             |              |
    cargo            | character varying(255)   |           |          |                   | extended |             |              |
    empresa          | character varying(255)   |           |          |                   | extended |             |              |
    direccion        | text                     |           |          |                   | extended |             |              |
    notas            | text                     |           |          |                   | extended |             |              |
    fecha_nacimiento | date                     |           |          |                   | plain    |             |              |
    es_padre         | boolean                  |           |          | false             | plain    |             |              |
    es_madre         | boolean                  |           |          | false             | plain    |             |              |
    created_at       | timestamp with time zone |           |          | CURRENT_TIMESTAMP | plain    |             |              |
    updated_at       | timestamp with time zone |           |          | CURRENT_TIMESTAMP | plain    |             |              |
    perfil_linkedin  | character varying(255)   |           |          |                   | extended |             |              |
    area_negocio     | character varying(100)   |           |          |                   | extended |             |              |
    user_id          | integer                  |           | not null |                   | plain    |             |              |
    Indexes:
        "contact_details_pkey" PRIMARY KEY, btree (user_id, cedula)
        "idx_contact_details_area_negocio" btree (area_negocio)
    Foreign-key constraints:
        "fk_cedula_contact_general" FOREIGN KEY (cedula) REFERENCES general(cedula) ON UPDATE CASCADE ON DELETE CASCADE
        "fk_user_contact_details" FOREIGN KEY (user_id, cedula) REFERENCES user_agendas(user_id, contact_cedula) ON DELETE CASCADE
    Access method: heap
    datos_ap-# \d+ contact_notes;
                                                                        Table "public.contact_notes"
        Column     |           Type           | Collation | Nullable |                  Default                  | Storage  | Compression | Stats target | Description
    ----------------+--------------------------+-----------+----------+-------------------------------------------+----------+-------------+--------------+-------------
    id             | integer                  |           | not null | nextval('contact_notes_id_seq'::regclass) | plain    |             |              |
    user_id        | integer                  |           | not null |                                           | plain    |             |              |
    contact_cedula | character varying(255)   |           | not null |                                           | extended |             |              |
    titulo         | character varying(255)   |           | not null |                                           | extended |             |              |
    cuerpo         | text                     |           |          |                                           | extended |             |              |
    fecha_nota     | timestamp with time zone |           |          | CURRENT_TIMESTAMP                         | plain    |             |              |
    Indexes:
        "contact_notes_pkey" PRIMARY KEY, btree (id)
    Foreign-key constraints:
        "contact_notes_user_id_contact_cedula_fkey" FOREIGN KEY (user_id, contact_cedula) REFERENCES user_agendas(user_id, contact_cedula) ON DELETE CASCADE
        "fk_contact_notes" FOREIGN KEY (user_id, contact_cedula) REFERENCES user_agendas(user_id, contact_cedula) ON DELETE CASCADE
    Access method: heap
    datos_ap-# \d+ follow_up_events;
                                                                            Table "public.follow_up_events"
            Column        |            Type             | Collation | Nullable |                   Default                    | Storage  | Compression | Stats target | Description
    ----------------------+-----------------------------+-----------+----------+----------------------------------------------+----------+-------------+--------------+-------------
    id                   | integer                     |           | not null | nextval('follow_up_events_id_seq'::regclass) | plain    |             |              |
    user_id              | integer                     |           | not null |                                              | plain    |             |              |
    title                | character varying(255)      |           | not null |                                              | extended |             |              |
    description          | text                        |           |          |                                              | extended |             |              |
    date                 | timestamp without time zone |           | not null |                                              | plain    |             |              |
    color                | character varying(7)        |           |          | '#1565C0'::character varying                 | extended |             |              |
    icon                 | character varying(255)      |           |          | 'mdi-pencil'::character varying              | extended |             |              |
    created_at           | timestamp without time zone |           |          | CURRENT_TIMESTAMP                            | plain    |             |              |
    updated_at           | timestamp without time zone |           |          | CURRENT_TIMESTAMP                            | plain    |             |              |
    contact_cedula       | character varying(255)      |           |          |                                              | extended |             |              |
    event_key            | character varying(255)      |           |          |                                              | extended |             |              |
    contexto_interaccion | character varying(255)      |           |          |                                              | extended |             |              |
    es_recordatorio      | boolean                     |           |          | false                                        | plain    |             |              |
    Indexes:
        "follow_up_events_pkey" PRIMARY KEY, btree (id)
        "follow_up_events_event_key_key" UNIQUE CONSTRAINT, btree (event_key)
        "idx_follow_up_events_contact_cedula" btree (contact_cedula)
    Foreign-key constraints:
        "fk_follow_up_event_contact" FOREIGN KEY (user_id, contact_cedula) REFERENCES user_agendas(user_id, contact_cedula) ON DELETE CASCADE
        "follow_up_events_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
    Access method: heap
    datos_ap-# \d+ categorias;
                                                                    Table "public.categorias"
        Column      |         Type          | Collation | Nullable |                Default                 | Storage  | Compression | Stats target | Description
    ------------------+-----------------------+-----------+----------+----------------------------------------+----------+-------------+--------------+-------------
    id               | integer               |           | not null | nextval('categorias_id_seq'::regclass) | plain    |             |              |
    nombre_categoria | character varying(50) |           | not null |                                        | extended |             |              |
    Indexes:
        "categorias_pkey" PRIMARY KEY, btree (id)
        "categorias_nombre_categoria_key" UNIQUE CONSTRAINT, btree (nombre_categoria)
    Referenced by:
        TABLE "user_agenda_categorias" CONSTRAINT "fk_user_agenda_categorias_categoria" FOREIGN KEY (categoria_id) REFERENCES categorias(id) ON DELETE CASCADE
        TABLE "user_agenda_categorias" CONSTRAINT "user_agenda_categorias_categoria_id_fkey" FOREIGN KEY (categoria_id) REFERENCES categorias(id) ON DELETE CASCADE
    Access method: heap
    datos_ap=# \d+ user_agenda_categorias;
                                                Table "public.user_agenda_categorias"
        Column     |          Type          | Collation | Nullable | Default | Storage  | Compression | Stats target | Description
    ----------------+------------------------+-----------+----------+---------+----------+-------------+--------------+-------------
    user_id        | integer                |           | not null |         | plain    |             |              |
    contact_cedula | character varying(255) |           | not null |         | extended |             |              |
    categoria_id   | integer                |           | not null |         | plain    |             |              |
    Indexes:
        "user_agenda_categorias_pkey" PRIMARY KEY, btree (user_id, contact_cedula, categoria_id)
        "idx_user_agenda_categorias_categoria_id" btree (categoria_id)
        "idx_user_agenda_categorias_user_id" btree (user_id)
    Foreign-key constraints:
        "fk_user_agenda_categorias_categoria" FOREIGN KEY (categoria_id) REFERENCES categorias(id) ON DELETE CASCADE
        "fk_user_agenda_categorias_user" FOREIGN KEY (user_id, contact_cedula) REFERENCES user_agendas(user_id, contact_cedula) ON DELETE CASCADE
        "user_agenda_categorias_categoria_id_fkey" FOREIGN KEY (categoria_id) REFERENCES categorias(id) ON DELETE CASCADE
        "user_agenda_categorias_user_id_contact_cedula_fkey" FOREIGN KEY (user_id, contact_cedula) REFERENCES user_agendas(user_id, contact_cedula) ON DELETE CASCADE
    Access method: heap
    -------
1. como vamos a bautizar nuestro componente..
2. revisar los stores pinia existentes ... para determinar la creacion de uno particular para la agenda...
3. ver la vista de la guia telefonica de donde se va a optener los contactos.. para tratarlos de forma profesional en nuestra nueva aplicacion de agenda..
4. Discusiones de funcionalidades... para la vista.. y alineamiento de de la lógica..
5. diseño final y ajustes. para implementar.
----
1. Nombramiento del Componente
Para mantener la consistencia y la claridad en tu proyecto, es crucial nombrar los componentes de forma descriptiva. Siguiendo las convenciones de Vue/Pinia y la lógica de tu aplicación, sugiero el siguiente nombre:
TheAgenda.vue: Este es un nombre simple, directo y profesional. "The" le da un sentido de ser el componente principal para esa funcionalidad. Alternativamente, podrías usar UserAgenda.vue para enfatizar que es una agenda personal por usuario, pero TheAgenda es más conciso y claro en el contexto de tu aplicación.
2. Revisión de Stores Pinia
Actualmente, no tienes un store de Pinia dedicado a la agenda. Crear uno es la mejor opción. Esto te permitirá gestionar el estado de manera centralizada, lo que es esencial para funcionalidades como:
Lista de Contactos de la Agenda: Un store puede almacenar y gestionar la lista de contactos que el usuario ha agregado a su agenda personal.
Gestión de Eventos y Categorías: Un store puede manejar la lógica para agregar, eliminar y actualizar eventos de seguimiento, así como la asignación de categorías.
Sincronización de Datos: El store se encargará de llamar a los endpoints del backend que acabamos de crear (/api/private-agenda/*) y de mantener los datos actualizados en la interfaz de usuario.
El nombre propuesto para el store es useAgendaStore.js.
3. Vista de la Guía Telefónica
La vista de la guía telefónica (GeneralData) es el punto de partida clave. El flujo de trabajo para que un usuario agregue un contacto a su agenda personal será el siguiente:
En la vista GeneralData: El usuario verá la lista completa de contactos de la tabla general.
Botón de Acción: Cada fila de la tabla deberá tener un botón (por ejemplo, con un ícono de "agregar a la agenda" o una estrella) que permita al usuario agregar ese contacto a su agenda personal.
Lógica del Evento: Al hacer clic en este botón, se debe disparar una acción que llame a tu nuevo useAgendaStore. Este store, a su vez, hará una solicitud POST al endpoint /api/private-agenda/agenda/add con la cédula del contacto.
Esto garantiza una separación de responsabilidades: el componente de la guía telefónica se encarga de mostrar los datos, y el store de la agenda se encarga de la lógica de negocio para agregar el contacto.
4. Discusión de Funcionalidades y Alineamiento Lógico
Esta es la fase de diseño. Consideremos las funcionalidades clave y cómo se alinean con tu backend:
Vista Principal de la Agenda: Deberá ser una tabla o una lista de contactos. Cada contacto debe mostrar su nombre (el personalizado si existe, si no el de la guía general), su cédula y una lista de sus teléfonos (los personales si existen, y si no, los globales).
Detalles del Contacto: Al hacer clic en un contacto, se debe abrir un modal o una vista lateral con pestañas que muestren:
Información Básica: El nombre personalizado, cargo, empresa, etc. (controlador contactDetailsController).
Teléfonos: La lista de teléfonos personales (controlador userTelefonosController).
Notas: Un campo de texto para notas personales (controlador contactNotesController).
Categorías: Una sección para asignar y mostrar categorías (controlador userCategoriesController).
Historial de Seguimiento: La lista de eventos de seguimiento con la fecha y las notas (controlador followupEventsController).
Cada una de estas pestañas se comunicará con su respectivo endpoint del backend para cargar, crear, actualizar o eliminar datos.
5. Diseño Final y Ajustes para la Implementación
Una vez que la lógica anterior esté clara, el diseño de la interfaz de usuario se hará mucho más fácil.
Estructura del Componente: El componente TheAgenda.vue contendrá la tabla principal. Utilizarás componentes secundarios para los modales o vistas de detalle de cada contacto. Por ejemplo, ContactDetailModal.vue, que a su vez contendrá ContactPhones.vue, ContactNotes.vue, etc.
Composición de la Interfaz: Usarás componentes de tu biblioteca de UI (como Vuetify) para las tablas, botones, formularios y modales, lo que acelerará el desarrollo y mantendrá la consistencia visual.
Este plan te dará un componente de agenda robusto, profesional y, sobre todo, seguro, ya que cada acción estará respaldada por la lógica del backend que has construido.
----
de los 5 puntos
vamos a realizar uno a uno...
cuando estemos satisfechos e indiquemos que finalizamos todo pasemos al siguiente punto hasta finalizar.. hagamos organiizadamente..
-----
----
Estudio Inicial
1. Información de contacto
Nombre completo: Nombre y apellido del contacto.
Número(s) de teléfono: Puedes tener varios (celular, casa, trabajo). Es útil categorizarlos.
Correo electrónico: Un campo para uno o más correos.
Dirección: Calle, número, ciudad, código postal, etc. Esto puede ser útil para la geolocalización o para envío de correspondencia.
Empresa y cargo: Si el contacto es profesional, estos datos son muy relevantes.
Relación: Puedes añadir un campo para saber qué tipo de relación tienes con la persona (amigo, familiar, colega, cliente, etc.). Esto puede ayudar a organizar y filtrar tus contactos.
2. Información complementari
Notas personales: Un campo de texto largo para añadir cualquier tipo de nota que no encaje en las otras categorías (por ejemplo, "Le gusta el café", "Cumpleaños en noviembre", "Reunión de seguimiento programada").
Fecha de cumpleaños o aniversario: Esto es útil para recibir recordatorios y fechas importantes.
Etiquetas o categorías: Permite etiquetar los contactos para agruparlos de manera más flexible, por ejemplo, "Proyecto A", "Futbol", "Familia". Esto facilitará mucho las búsquedas y filtros.
Foto de perfil: Una imagen pequeña del contacto.
3. Aspectos técnicos y de diseño
ID del contacto: Un identificador único (ID) para cada registro en tu base de datos.
Fecha de adición: La fecha en que el contacto fue añadido a tu agenda personal.
Fecha de última modificación: La fecha en que se actualizó por última vez la información del contacto.
Ícono de estrella: Para la funcionalidad que mencionas, la estrella, puedes usarla como un toggle que actualiza un campo en la base de datos de la guía telefónica. Podrías llamarlo es_favorito o en_agenda_personal, con un valor booleano (true/false). Al presionar el ícono, el contacto se "copia" o, mejor aún, se asocia a la agenda personal del usuario.
----- Avanzado
Campos de Contacto Esenciales
Estos campos te permiten capturar la información fundamental de un contacto profesional.
Información de la Persona:
Nombre Completo (nombre, apellidos).
Cargo/Puesto (cargo).
Empresa/Organización (empresa).
Área de Negocio (por ejemplo, "Finanzas", "Marketing", "Recursos Humanos").
Datos de Contacto:
Teléfonos (pueden ser varios: teléfono_oficina, celular, etc.).
Correo Electrónico (email_profesional, email_personal).
Dirección de la Oficina.
Perfil de LinkedIn/Red Profesional.
Anotaciones y Seguimiento (La Clave de una Agenda Profesional)
Aquí es donde tu agenda se convierte en una herramienta estratégica.
Notas de Interacción: Un campo de texto (notas) para registrar los detalles de tus interacciones.
"Llamada el 15/09/2025 para discutir la propuesta del proyecto X."
"Reunión con el equipo el 18/09/2025. Juan Carlos se mostró interesado en la fase 2."
Fecha de Última Interacción: Un campo automático que registre la última vez que te comunicaste con el contacto. Esto es vital para saber cuándo necesitas retomar el contacto.
Próximo Seguimiento: Un campo para programar la próxima vez que te pondrás en contacto con la persona. Por ejemplo, "Llamar en 3 semanas para dar seguimiento al presupuesto."
Contexto de la Relación: Un campo para indicar cómo conociste al contacto (por ejemplo, "Conferencia de IT 2025", "Recomendado por Pedro López").
Relación Clave: Marca el tipo de relación profesional: Cliente, Socio, Proveedor, Colega, Inversor, etc. Esto te permite filtrar y organizar tu red.
Eventos y Tareas Relacionadas: Crea tareas o eventos específicos vinculados al contacto (por ejemplo, "Enviar propuesta", "Preparar presentación").
Campos Adicionales y Funcionalidades
Para un nivel más avanzado, considera:
Etiquetas Personalizadas: Permite a los usuarios crear sus propias etiquetas, como Proyecto Alpha, Networking, Potencial Socio, para una organización aún más granular.
Fechas Importantes: Además del cumpleaños, puedes incluir la fecha de su aniversario en la empresa o la fecha de la firma de un contrato importante.
------
Con los detalles que me has proporcionado, que incluyen la estructura de las tablas, los campos avanzados y las funcionalidades deseadas, el camino para construir la interfaz perfecta para TheAgenda.vue está muy claro. La clave es diseñar una interfaz que no solo muestre los datos, sino que también facilite el flujo de trabajo del usuario para que la agenda sea una herramienta estratégica, no solo una lista de contactos.
Mi propuesta se basa en un diseño modular y enfocado en la usabilidad, aprovechando la separación de responsabilidades que ya tienes en tus tablas.
1. Vista Principal: TheAgenda.vue
El diseño principal debe ser limpio y funcional, mostrando una lista de contactos que sea fácil de navegar y filtrar. Un diseño con una lista de tarjetas (V-Card) o una tabla de datos compacta es la mejor opción. Sugiero usar una tabla con capacidades de búsqueda y filtrado.
Tabla de Contactos: Similar a la guía telefónica, pero mostrando solo los contactos de la agenda del usuario.
Columnas Clave: Muestra los datos más relevantes de un vistazo: Nombre Completo, Empresa, Cargo, Teléfono Principal (el que el usuario haya marcado como principal en su agenda), Última Interacción y Próximo Seguimiento.
Acciones Rápidas: En cada fila, iconos de acción rápida para las tareas más comunes:
📞 Llamar: Un icono de teléfono para la acción openWhatsApp o similar.
⭐ Desafiar: Un icono de estrella (mdi-star) que, al hacer clic, elimina el contacto de la agenda personal.
📝 Notas: Un icono para agregar una nueva nota.
🗓️ Seguimiento: Un icono para programar un evento de seguimiento.
Barra de Herramientas Superior:
Buscador Global: Un campo de búsqueda que filtre por todos los campos visibles (nombre, empresa, cargo, etc.).
Filtros Inteligentes: Botones o un menú desplegable para filtrar por las categorías personalizadas del usuario (user_agenda_categorias). Por ejemplo: "Clientes", "Familia", "Proyecto X".
Botón de Adición: Aunque los contactos se agregan desde la guía, un botón de "Añadir contacto nuevo" permitiría al usuario agregar personas que no estén en la guía pública. Esto activaría un formulario modal.
2. Formulario de Detalles del Contacto (Modal)
Cuando el usuario haga clic en un contacto de la tabla, se debe abrir un modal o un panel lateral que muestre todos los detalles. Este modal debe ser el centro de la interacción y la personalización. La interfaz debe ser intuitiva y visualmente atractiva, con secciones para cada tipo de información.
Pestañas/Secciones: El modal se dividiría en pestañas o secciones para no sobrecargar al usuario:
Información General:
Datos Principales: Muestra el nombre completo, cargo, empresa y los datos que provienen de las tablas general y contact_details.
Edición Personalizada: Los campos de la tabla user_nombres, user_telefonos, y contact_details deben ser editables. Por ejemplo, el usuario podría cambiar el nombre de "Juan Pérez" a "Juanito (Cliente)".
Categorías: Un campo de etiquetas (V-Chip) para asignar y desasignar categorías personalizadas (categorias).
Notas y Seguimiento:
Historial de Notas: Una lista ordenada cronológicamente de todas las notas de la tabla contact_notes. Cada nota debería tener una fecha y un título. Un botón de "Nueva Nota" permitiría añadir un nuevo registro.
Próximos Eventos: Una lista de los próximos eventos o recordatorios de la tabla follow_up_events. Un botón de "Añadir Seguimiento" abriría un pequeño formulario para crear un nuevo evento.
Archivos y Documentos:
Esta funcionalidad, aunque no la mencionaste, podría ser una adición avanzada. Un área para adjuntar documentos relevantes (contratos, propuestas) asociados al contacto. Esto usaría una tabla tipo contact_documents.
// src/controllers/contactDetails.controller.js
const { pool } = require('../db/db');
/**
 * Crea o actualiza los detalles de un contacto en la agenda personal del usuario.
 * Utiliza un "upsert" para simplificar la lógica.
 * @param {object} req - Objeto de solicitud de Express.
 * @param {object} res - Objeto de respuesta de Express.
 */
const upsertContactDetails = async (req, res) => {
    const { cedula, cargo, empresa, direccion, fecha_nacimiento, perfil_linkedin, area_negocio } = req.body;
    const { id: user_id } = req.user;
    if (!cedula) {
        return res.status(400).json({ error: 'La cédula del contacto es requerida.' });
    }
    try {
        const query = `
            INSERT INTO contact_details (user_id, cedula, cargo, empresa, direccion, fecha_nacimiento, perfil_linkedin, area_negocio)
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
            ON CONFLICT (user_id, cedula) DO UPDATE SET
                cargo = EXCLUDED.cargo,
                empresa = EXCLUDED.empresa,
                direccion = EXCLUDED.direccion,
                fecha_nacimiento = EXCLUDED.fecha_nacimiento,
                perfil_linkedin = EXCLUDED.perfil_linkedin,
                area_negocio = EXCLUDED.area_negocio,
                updated_at = NOW()
            RETURNING *;
        `;
        const result = await pool.query(query, [user_id, cedula, cargo, empresa, direccion, fecha_nacimiento, perfil_linkedin, area_negocio]);
        res.status(200).json(result.rows[0]);
    } catch (err) {
        console.error('Error al crear o actualizar los detalles del contacto:', err);
        res.status(500).json({ error: 'Error del servidor.', details: err.detail });
    }
};
/**
 * Obtiene los detalles personalizados de un contacto específico del usuario.
 * @param {object} req - Objeto de solicitud de Express.
 * @param {object} res - Objeto de respuesta de Express.
 */
const getContactDetails = async (req, res) => {
    const { cedula } = req.params;
    const { id: user_id } = req.user;
    try {
        const query = `
            SELECT *
            FROM contact_details
            WHERE user_id = $1 AND cedula = $2;
        `;
        const result = await pool.query(query, [user_id, cedula]);
        if (result.rowCount === 0) {
            return res.status(404).json({ error: 'Detalles del contacto no encontrados.' });
        }
        res.json(result.rows[0]);
    } catch (err) {
        console.error('Error al obtener los detalles del contacto:', err);
        res.status(500).json({ error: 'Error del servidor.', details: err.detail });
    }
};
module.exports = {
    upsertContactDetails,
    getContactDetails,
};
-
// src/controllers/contactNotes.controller.js
const { pool } = require('../db/db');
/**
 * Crea o actualiza una nota para un contacto en la agenda del usuario.
 * @param {object} req - Objeto de solicitud de Express.
 * @param {object} res - Objeto de respuesta de Express.
 */
const upsertContactNote = async (req, res) => {
    const { contact_cedula, nota } = req.body;
    const { id: user_id } = req.user;
    if (!contact_cedula || !nota) {
        return res.status(400).json({ error: 'La cédula del contacto y la nota son requeridas.' });
    }
    try {
        const query = `
            INSERT INTO contact_notes (user_id, contact_cedula, nota)
            VALUES ($1, $2, $3)
            ON CONFLICT (user_id, contact_cedula) DO UPDATE SET
                nota = EXCLUDED.nota,
                updated_at = NOW()
            RETURNING *;
        `;
        const result = await pool.query(query, [user_id, contact_cedula, nota]);
        res.status(200).json(result.rows[0]);
    } catch (err) {
        console.error('Error al guardar la nota:', err);
        res.status(500).json({ error: 'Error del servidor.', details: err.detail });
    }
};
module.exports = {
    upsertContactNote,
};
-
// src/controllers/followupEvents.controller.js
const { pool } = require('../db/db');
/**
 * Crea un nuevo evento de seguimiento para un contacto.
 * @param {object} req - Objeto de solicitud de Express.
 * @param {object} res - Objeto de respuesta de Express.
 */
const createFollowupEvent = async (req, res) => {
    const { contact_cedula, tipo_evento, fecha, notas } = req.body;
    const { id: user_id } = req.user;
    if (!contact_cedula || !tipo_evento || !fecha) {
        return res.status(400).json({ error: 'La cédula, tipo de evento y fecha son requeridos.' });
    }
    try {
        const query = `
            INSERT INTO follow_up_events (user_id, contact_cedula, tipo_evento, fecha, notas)
            VALUES ($1, $2, $3, $4, $5)
            RETURNING *;
        `;
        const result = await pool.query(query, [user_id, contact_cedula, tipo_evento, fecha, notas]);
        res.status(201).json(result.rows[0]);
    } catch (err) {
        console.error('Error al crear el evento de seguimiento:', err);
        res.status(500).json({ error: 'Error del servidor.', details: err.detail });
    }
};
/**
 * Obtiene todos los eventos de seguimiento para un contacto específico,
 * que pertenecen al usuario autenticado.
 * @param {object} req - Objeto de solicitud de Express.
 * @param {object} res - Objeto de respuesta de Express.
 */
const getFollowupEventsByContact = async (req, res) => {
    const { contact_cedula } = req.params;
    const { id: user_id } = req.user;
   try {
        const query = `
            SELECT * FROM follow_up_events
            WHERE user_id = $1 AND contact_cedula = $2
            ORDER BY fecha DESC;
        `;
        const result = await pool.query(query, [user_id, contact_cedula]);
        res.json(result.rows);
    } catch (err) {
        console.error('Error al obtener los eventos de seguimiento:', err);
        res.status(500).json({ error: 'Error del servidor.', details: err.detail });
    }
};
/**
 * Elimina un evento de seguimiento. Solo el creador puede eliminarlo.
 * @param {object} req - Objeto de solicitud de Express.
 * @param {object} res - Objeto de respuesta de Express.
 */
const deleteFollowupEvent = async (req, res) => {
    const { id } = req.params;
    const { id: user_id } = req.user;
    try {
        const query = `
            DELETE FROM follow_up_events
            WHERE id = $1 AND user_id = $2
            RETURNING *;
        `;
        const result = await pool.query(query, [id, user_id]);
        if (result.rowCount === 0) {
            return res.status(404).json({ error: 'Evento no encontrado o no tienes permiso para eliminarlo.' });
        }     
        res.status(200).json({ message: 'Evento eliminado correctamente.' });
    } catch (err) {
        console.error('Error al eliminar el evento:', err);
        res.status(500).json({ error: 'Error del servidor.', details: err.detail });
    }
};
module.exports = {
    createFollowupEvent,
    getFollowupEventsByContact,
    deleteFollowupEvent,
};
-
const { pool } = require('../db/db');
const { upsertGeneral } = require('./general.controller'); 
/**
 * Agrega un contacto a la agenda privada del usuario.
 */
const addContactToAgenda = async (req, res) => {
    const { id: userId } = req.user;
    const { contactCedula } = req.body;
    const client = await pool.connect();
    try {
        await client.query('BEGIN');
        // Insertar el contacto en la agenda del usuario
        const insertQuery = `
            INSERT INTO user_agendas (user_id, contact_cedula)
            VALUES ($1, $2)
            RETURNING *;
        `;
        const result = await client.query(insertQuery, [userId, contactCedula]);
        await client.query('COMMIT');
        res.status(201).json({ message: 'Contacto agregado a la agenda privada.', contact: result.rows[0] });
    } catch (err) {
        await client.query('ROLLBACK');
        console.error('Error al agregar contacto a la agenda privada:', err);
        if (err.code === '23505') { // Error de clave duplicada
            res.status(409).json({ error: 'El contacto ya está en tu agenda privada.', details: err.detail });
        } else {
            res.status(500).json({ error: 'Error del servidor.', details: err.detail });
        }
    } finally {
        client.release();
    }
};
/**
 * Obtiene solo la lista de cédulas de la agenda privada del usuario.
 */
const getPrivateAgendaCedulas = async (req, res) => {
    const { id: userId } = req.user;
    try {
        const query = `
            SELECT contact_cedula
            FROM user_agendas
            WHERE user_id = $1;
        `;
        const result = await pool.query(query, [userId]);
        const cedulas = result.rows.map(row => row.contact_cedula);
        res.json(cedulas);
    } catch (err) {
        console.error('Error al obtener las cédulas de la agenda privada:', err);
        res.status(500).json({ error: 'Error del servidor' });
    }
};
/**
 * Obtiene la lista completa de contactos de la agenda privada del usuario.
 */
const getPrivateAgenda = async (req, res) => {
    const { id: userId } = req.user;
    const { page = 1, itemsPerPage = 10, search = '' } = req.query;
    const limit = Math.min(parseInt(itemsPerPage), 100);
    const offset = (parseInt(page) - 1) * limit;
    let whereClause = `WHERE ua.user_id = $1`;
    const queryParams = [userId];
    let paramIndex = 2;
    if (search) {
        const searchTerms = search.split(/\s+/).filter(term => term);
        if (searchTerms.length > 0) {
            whereClause += ` AND g.search_vector @@ to_tsquery('spanish', $${paramIndex})`;
            queryParams.push(searchTerms.map(t => `${t}:*`).join(' & '));
            paramIndex++;
        }
    }
    try {
        const countQuery = `SELECT COUNT(*) FROM user_agendas ua JOIN general g ON ua.contact_cedula = g.cedula ${whereClause}`;
        const countResult = await pool.query(countQuery, queryParams);
        const totalItems = parseInt(countResult.rows[0].count);
        const dataQuery = `
            SELECT
                ua.contact_cedula AS cedula,
                g.nombres,
                g.apellidos,
                g.completo,
                cd.cargo,
                cd.empresa,
                cd.direccion,
                cd.notas,
                cd.fecha_nacimiento,
                cd.es_padre,
                cd.es_madre,
                json_agg(t.numero) FILTER (WHERE t.numero IS NOT NULL) AS telefonos
            FROM
                user_agendas ua
            JOIN
                general g ON ua.contact_cedula = g.cedula
            LEFT JOIN
                contact_details cd ON ua.contact_cedula = cd.cedula
            LEFT JOIN
                telefonos t ON g.cedula = t.cedula_persona
            ${whereClause}
            GROUP BY
                ua.contact_cedula, g.nombres, g.apellidos, g.completo, cd.cedula
            ORDER BY
                g.nombres ASC
            LIMIT $${paramIndex} OFFSET $${paramIndex + 1};
        `;
        queryParams.push(limit);
        queryParams.push(offset);
        const dataResult = await pool.query(dataQuery, queryParams);
        const items = dataResult.rows;
        res.json({ items, totalItems });
    } catch (err) {
        console.error('Error al obtener la agenda privada:', err);
        res.status(500).json({ error: 'Error del servidor' });
    }
};
/**
 * Actualiza los detalles de un contacto en la tabla 'contact_details'.
 */
const updateContactDetails = async (req, res) => {
    const { contactCedula } = req.params;
    const { cargo, empresa, direccion, notas, fechaNacimiento, esPadre, esMadre } = req.body;
    try {
        // Verificar si el contacto existe en la agenda del usuario
        const agendaCheck = await pool.query('SELECT user_id FROM user_agendas WHERE user_id = $1 AND contact_cedula = $2', [req.user.id, contactCedula]);
        if (agendaCheck.rowCount === 0) {
            return res.status(403).json({ error: 'No tienes permiso para editar este contacto o no existe en tu agenda.' });
        }
        const query = `
            INSERT INTO contact_details (
                cedula, cargo, empresa, direccion, notas, fecha_nacimiento, es_padre, es_madre, updated_at
            ) VALUES (
                $1, $2, $3, $4, $5, $6, $7, $8, NOW()
            )
            ON CONFLICT (cedula) DO UPDATE SET
                cargo = EXCLUDED.cargo,
                empresa = EXCLUDED.empresa,
                direccion = EXCLUDED.direccion,
                notas = EXCLUDED.notas,
                fecha_nacimiento = EXCLUDED.fecha_nacimiento,
                es_padre = EXCLUDED.es_padre,
                es_madre = EXCLUDED.es_madre,
                updated_at = NOW()
            RETURNING *;
        `;
        const values = [contactCedula, cargo, empresa, direccion, notas, fechaNacimiento, esPadre, esMadre];
        const result = await pool.query(query, values);   
        res.json({ message: 'Detalles del contacto actualizados.', updatedRecord: result.rows[0] });
    } catch (err) {
        console.error('Error al actualizar detalles del contacto:', err);
        res.status(500).json({ error: 'Error del servidor', details: err.detail });
    }
};
/**
 * Elimina un contacto de la agenda privada de un usuario.
 * También limpia los detalles del contacto si ya no está en la agenda de ningún otro usuario.
 */
const deleteContactFromAgenda = async (req, res) => {
    const { contactCedula } = req.params;
    const { id: userId } = req.user;
    const client = await pool.connect();
    try {
        await client.query('BEGIN');
        // Paso 1: Eliminar el contacto de la agenda privada del usuario
        const deleteAgendaQuery = `
            DELETE FROM user_agendas
            WHERE user_id = $1 AND contact_cedula = $2
            RETURNING *;
        `;
        const result = await client.query(deleteAgendaQuery, [userId, contactCedula]);
        if (result.rowCount === 0) {
            await client.query('ROLLBACK');
            return res.status(404).json({ error: 'El contacto no se encontró en tu agenda privada.' });
        }
        // Paso 2: Verificar si el contacto aún existe en la agenda de otro usuario
        const checkOthersQuery = `
            SELECT 1
            FROM user_agendas
            WHERE contact_cedula = $1
            LIMIT 1;
        `;
        const othersResult = await client.query(checkOthersQuery, [contactCedula]);
        // Si no se encontraron otros registros, es seguro eliminar los detalles del contacto
        if (othersResult.rowCount === 0) {
            const deleteDetailsQuery = `
                DELETE FROM contact_details
                WHERE cedula = $1
                RETURNING *;
            `;
            await client.query(deleteDetailsQuery, [contactCedula]);
            console.log(`Detalles del contacto ${contactCedula} eliminados porque ya no está en la agenda de ningún usuario.`);
        }      
        await client.query('COMMIT');
        res.json({ message: 'Contacto eliminado de la agenda exitosamente.', deletedRecord: result.rows[0] });
    } catch (err) {
        await client.query('ROLLBACK');
        console.error('Error al eliminar contacto de la agenda:', err);
        res.status(500).json({ error: 'Error del servidor', details: err.detail });
    } finally {
        client.release();
    }
};
module.exports = {
    addContactToAgenda,
    getPrivateAgenda,
    getPrivateAgendaCedulas,
    updateContactDetails,
    deleteContactFromAgenda,
};
----
// src/controllers/userAgenda.controller.js
const { pool } = require('../db/db');
/**
 * Agrega un contacto de la guía global a la agenda personal de un usuario.
 * @param {object} req - Objeto de solicitud de Express.
 * @param {object} res - Objeto de respuesta de Express.
 */
const addContactToAgenda = async (req, res) => {
    const { contact_cedula } = req.body;
    const { id: user_id } = req.user;
    if (!contact_cedula) {
        return res.status(400).json({ error: 'La cédula del contacto es requerida.' });
    }
    try {
        // Paso 1: Insertar el contacto en la tabla principal `user_agendas`.
        // Esta es la operación obligatoria para establecer el vínculo.
        // Se utiliza ON CONFLICT para manejar duplicados de manera eficiente.
        const insertAgendaQuery = `
            INSERT INTO user_agendas (user_id, contact_cedula)
            VALUES ($1, $2)
            ON CONFLICT (user_id, contact_cedula) DO NOTHING
            RETURNING *;
        `;
        const agendaResult = await pool.query(insertAgendaQuery, [user_id, contact_cedula]);
        // Si el contacto ya existía y no se hizo una inserción (rowCount === 0), salimos.
        if (agendaResult.rowCount === 0) {
            return res.status(409).json({ message: 'El contacto ya existe en tu agenda.' });
        }
        // Paso 2: Obtener los datos del contacto de la tabla `general` para la respuesta.
        const generalContactQuery = `
            SELECT g.completo, t.telefonos
            FROM general g
            LEFT JOIN mv_telefonos_agregados t ON g.cedula = t.cedula
            WHERE g.cedula = $1;
        `;
        const generalContactResult = await pool.query(generalContactQuery, [contact_cedula]);
        if (generalContactResult.rows.length === 0) {
            // Esto es una validación de seguridad.
            return res.status(404).json({ error: 'Contacto no encontrado en la guía general.' });
        }   
        const { completo, telefonos } = generalContactResult.rows[0];
        // Se prepara el objeto de respuesta con los datos de la guía global.
        const newContact = {
            contact_cedula: contact_cedula,
            nombre_completo: completo,
            telefonos: telefonos,
        };
        res.status(201).json({ message: 'Contacto agregado a la agenda personal.', data: newContact });
    } catch (err) {
        console.error('Error al agregar contacto a la agenda personal:', err);
        res.status(500).json({ error: 'Error del servidor.', details: err.detail });
    }
};
/**
 * Obtiene todos los contactos de la agenda personal de un usuario.
 * @param {object} req - Objeto de solicitud de Express.
 * @param {object} res - Objeto de respuesta de Express.
 */
const getMyAgendaContacts = async (req, res) => {
    const { id: user_id } = req.user;
    try {
        const query = `
            SELECT
                ua.contact_cedula,
                COALESCE(unn.nombre_personalizado, g.completo) AS nombre_completo,
                COALESCE(ut.telefonos, t.telefonos) AS telefonos,
                ua.created_at
            FROM
                user_agendas ua
            LEFT JOIN
                general g ON ua.contact_cedula = g.cedula
            LEFT JOIN
                mv_telefonos_agregados t ON g.cedula = t.cedula
            LEFT JOIN
                user_nombres unn ON ua.user_id = unn.user_id AND ua.contact_cedula = unn.contact_cedula
            LEFT JOIN
                (
                    SELECT
                        user_id,
                        contact_cedula,
                        json_agg(numero) AS telefonos
                    FROM
                        user_telefonos
                    WHERE
                        user_id = $1
                    GROUP BY
                        user_id, contact_cedula
                ) ut ON ua.user_id = ut.user_id AND ua.contact_cedula = ut.contact_cedula
            WHERE
                ua.user_id = $1
            ORDER BY
                nombre_completo ASC;
        `;
        const result = await pool.query(query, [user_id]);
        res.json(result.rows);
    } catch (err) {
        console.error('Error al obtener la agenda del usuario:', err);
        res.status(500).json({ error: 'Error del servidor.', details: err.detail });
    }
};
/**
 * Elimina un contacto de la agenda personal de un usuario.
 * @param {object} req - Objeto de solicitud de Express.
 * @param {object} res - Objeto de respuesta de Express.
 */
const removeContactFromAgenda = async (req, res) => {
    const { contact_cedula } = req.params;
    const { id: user_id } = req.user;
    try {
        const query = `
            DELETE FROM user_agendas
            WHERE user_id = $1 AND contact_cedula = $2
            RETURNING *;
        `;
        const result = await pool.query(query, [user_id, contact_cedula]);
        if (result.rowCount === 0) {
            return res.status(404).json({ error: 'El contacto no se encontró en tu agenda.' });
        }
        res.json({ message: 'Contacto eliminado de tu agenda.' });
    } catch (err) {
        console.error('Error al eliminar contacto de la agenda:', err);
        res.status(500).json({ error: 'Error del servidor.', details: err.detail });
    }
};
module.exports = {
    addContactToAgenda,
    getMyAgendaContacts,
    removeContactFromAgenda,
};
---
// src/controllers/userCategories.controller.js
const { pool } = require('../db/db');
/**
 * Obtiene todas las categorías predefinidas.
 * Estas categorías pueden ser creadas y gestionadas por un rol con permisos elevados (ej. administrador).
 * @param {object} req - Objeto de solicitud de Express.
 * @param {object} res - Objeto de respuesta de Express.
 */
const getPredefinedCategories = async (req, res) => {
    try {
        const query = 'SELECT id, nombre, created_at FROM categorias ORDER BY nombre ASC;';
        const result = await pool.query(query);
        res.json(result.rows);
    } catch (err) {
        console.error('Error al obtener las categorías predefinidas:', err);
        res.status(500).json({ error: 'Error del servidor.', details: err.detail });
    }
};
/**
 * Asigna una categoría a un contacto en la agenda personal de un usuario.
 * @param {object} req - Objeto de solicitud de Express.
 * @param {object} res - Objeto de respuesta de Express.
 */
const assignCategoryToContact = async (req, res) => {
    const { contact_cedula, categoria_id } = req.body;
    const { id: user_id } = req.user;
    if (!contact_cedula || !categoria_id) {
        return res.status(400).json({ error: 'La cédula del contacto y el ID de la categoría son requeridos.' });
    }
    try {
        const query = `
            INSERT INTO user_agenda_categorias (user_id, contact_cedula, categoria_id)
            VALUES ($1, $2, $3)
            ON CONFLICT (user_id, contact_cedula, categoria_id) DO NOTHING
            RETURNING *;
        `;
        const result = await pool.query(query, [user_id, contact_cedula, categoria_id]);
        if (result.rowCount === 0) {
            return res.status(409).json({ message: 'La categoría ya está asignada a este contacto.' });
        }
        res.status(201).json(result.rows[0]);
    } catch (err) {
        console.error('Error al asignar la categoría al contacto:', err);
        res.status(500).json({ error: 'Error del servidor.', details: err.detail });
    }
};
/**
 * Obtiene las categorías asignadas a un contacto específico de un usuario.
 * @param {object} req - Objeto de solicitud de Express.
 * @param {object} res - Objeto de respuesta de Express.
 */
const getCategoriesByContact = async (req, res) => {
    const { contact_cedula } = req.params;
    const { id: user_id } = req.user;
    try {
        const query = `
            SELECT
                uac.id,
                uac.categoria_id,
                c.nombre AS nombre_categoria
            FROM
                user_agenda_categorias uac
            JOIN
                categorias c ON uac.categoria_id = c.id
            WHERE
                uac.user_id = $1 AND uac.contact_cedula = $2;
        `;
        const result = await pool.query(query, [user_id, contact_cedula]);
        res.json(result.rows);
    } catch (err) {
        console.error('Error al obtener las categorías del contacto:', err);
        res.status(500).json({ error: 'Error del servidor.', details: err.detail });
    }
};
/**
 * Elimina una categoría de un contacto.
 * @param {object} req - Objeto de solicitud de Express.
 * @param {object} res - Objeto de respuesta de Express.
 */
const removeCategoryFromContact = async (req, res) => {
    const { id } = req.params;
    const { id: user_id } = req.user;
    try {
        const query = `
            DELETE FROM user_agenda_categorias
            WHERE id = $1 AND user_id = $2
            RETURNING *;
        `;
        const result = await pool.query(query, [id, user_id]);
        if (result.rowCount === 0) {
            return res.status(404).json({ error: 'Asignación de categoría no encontrada o no tienes permiso para eliminarla.' });
        }
        res.status(200).json({ message: 'Categoría eliminada del contacto correctamente.' });
    } catch (err) {
        console.error('Error al eliminar la categoría del contacto:', err);
        res.status(500).json({ error: 'Error del servidor.', details: err.detail });
    }
};
module.exports = {
    getPredefinedCategories,
    assignCategoryToContact,
    getCategoriesByContact,
    removeCategoryFromContact,
};
---
// src/controllers/userNombres.controller.js
const { pool } = require('../db/db');
/**
 * Crea o actualiza un nombre personalizado para un contacto en la agenda del usuario.
 * @param {object} req - Objeto de solicitud de Express.
 * @param {object} res - Objeto de respuesta de Express.
 */
const upsertUserNombre = async (req, res) => {
    const { contact_cedula, nombre_personalizado } = req.body;
    const { id: user_id } = req.user;
    if (!contact_cedula || !nombre_personalizado) {
        return res.status(400).json({ error: 'La cédula y el nombre personalizado son requeridos.' });
    }
    try {
        const query = `
            INSERT INTO user_nombres (user_id, contact_cedula, nombre_personalizado)
            VALUES ($1, $2, $3)
            ON CONFLICT (user_id, contact_cedula) DO UPDATE SET
                nombre_personalizado = EXCLUDED.nombre_personalizado,
                updated_at = NOW()
            RETURNING *;
        `;
        const result = await pool.query(query, [user_id, contact_cedula, nombre_personalizado]);
        res.status(200).json(result.rows[0]);
    } catch (err) {
        console.error('Error al guardar el nombre personalizado:', err);
        res.status(500).json({ error: 'Error del servidor.', details: err.detail });
    }
};
module.exports = {
    upsertUserNombre,
};
----
// src/controllers/userTelefonos.controller.js
const { pool } = require('../db/db');
/**
 * Agrega un nuevo número de teléfono personal a un contacto de la agenda.
 * @param {object} req - Objeto de solicitud de Express.
 * @param {object} res - Objeto de respuesta de Express.
 */
const addUserTelefono = async (req, res) => {
    const { contact_cedula, numero } = req.body;
    const { id: user_id } = req.user;
    if (!contact_cedula || !numero) {
        return res.status(400).json({ error: 'La cédula y el número de teléfono son requeridos.' });
    }
    try {
        const query = `
            INSERT INTO user_telefonos (user_id, contact_cedula, numero)
            VALUES ($1, $2, $3)
            ON CONFLICT (user_id, numero) DO NOTHING
            RETURNING *;
        `;
        const result = await pool.query(query, [user_id, contact_cedula, numero]);
        if (result.rowCount === 0) {
            return res.status(409).json({ message: 'El número de teléfono ya existe para este contacto en tu agenda.' });
        }
        res.status(201).json(result.rows[0]);
    } catch (err) {
        console.error('Error al agregar teléfono personal:', err);
        res.status(500).json({ error: 'Error del servidor.', details: err.detail });
    }
};
/**
 * Elimina un número de teléfono personal de un contacto de la agenda.
 * @param {object} req - Objeto de solicitud de Express.
 * @param {object} res - Objeto de respuesta de Express.
 */
const removeUserTelefono = async (req, res) => {
    const { id } = req.params; // El ID del registro en user_telefonos
    const { id: user_id } = req.user;
    try {
        const query = `
            DELETE FROM user_telefonos
            WHERE id = $1 AND user_id = $2
            RETURNING *;
        `;
        const result = await pool.query(query, [id, user_id]);
        if (result.rowCount === 0) {
            return res.status(404).json({ error: 'Teléfono no encontrado o no tienes permiso para eliminarlo.' });
        }
        res.status(200).json({ message: 'Teléfono eliminado correctamente.' });
    } catch (err) {
        console.error('Error al eliminar teléfono personal:', err);
        res.status(500).json({ error: 'Error del servidor.', details: err.detail });
    }
};
module.exports = {
    addUserTelefono,
    removeUserTelefono,
};
-
// src/routes/privateAgenda.routes.js
const express = require('express');
const router = express.Router();
// Importar todos los controladores de la agenda personal
const userAgendaController = require('../controllers/userAgenda.controller');
const contactDetailsController = require('../controllers/contactDetails.controller');
const userNombresController = require('../controllers/userNombres.controller');
const userTelefonosController = require('../controllers/userTelefonos.controller');
const contactNotesController = require('../controllers/contactNotes.controller');
const followupEventsController = require('../controllers/followupEvents.controller');
const userCategoriesController = require('../controllers/userCategories.controller');
// Importar los middlewares de autenticación y autorización
const { authenticateJWT } = require('../middlewares/auth.middleware');
// Aplicar el middleware de autenticación a todas las rutas de la agenda privada
router.use(authenticateJWT);
// --- Rutas para la Agenda Personal (user_agendas) ---
// Obtener todos los contactos de la agenda del usuario
router.get('/agenda', userAgendaController.getMyAgendaContacts);
// Añadir un contacto de la tabla 'general' a la agenda del usuario
router.post('/agenda/add', userAgendaController.addContactToAgenda);
// Eliminar un contacto de la agenda del usuario
router.delete('/agenda/:contact_cedula', userAgendaController.removeContactFromAgenda);
// --- Rutas para los Detalles del Contacto (contact_details) ---
// Crear o actualizar detalles personalizados de un contacto
router.post('/agenda/details', contactDetailsController.upsertContactDetails);
// Obtener los detalles personalizados de un contacto específico
router.get('/agenda/details/:cedula', contactDetailsController.getContactDetails);
// --- Rutas para los Nombres Personalizados (user_nombres) ---
// Crear o actualizar un nombre personalizado para un contacto
router.post('/agenda/nombre', userNombresController.upsertUserNombre);
// Agregar un teléfono personal a un contacto
router.post('/agenda/telefono', userTelefonosController.addUserTelefono);
// Eliminar un teléfono personal de un contacto
router.delete('/agenda/telefono/:id', userTelefonosController.removeUserTelefono);
router.post('/agenda/note', contactNotesController.upsertContactNote);
router.post('/agenda/events', followupEventsController.createFollowupEvent);
// Obtener todos los eventos para un contacto
router.get('/agenda/events/:contact_cedula', followupEventsController.getFollowupEventsByContact);
// Eliminar un evento de seguimiento por ID
router.delete('/agenda/events/:id', followupEventsController.deleteFollowupEvent);
// Obtener la lista de categorías predefinidas
router.get('/agenda/categories', userCategoriesController.getPredefinedCategories);
// Asignar una categoría a un contacto
router.post('/agenda/categories', userCategoriesController.assignCategoryToContact);
// Obtener las categorías de un contacto específico
router.get('/agenda/categories/:contact_cedula', userCategoriesController.getCategoriesByContact);
// Eliminar una categoría de un contacto
router.delete('/agenda/categories/:id', userCategoriesController.removeCategoryFromContact);
module.exports = router;
----
Mapeo de Endpoints y Funcionalidades
A continuación, se detalla el plan de integración para cada micro-componente, basándonos en las rutas que definiste:
TheAgenda.vue (Orquestador principal)
Este componente principal se encargará de:
Obtener la lista de contactos: Utilizará el endpoint GET /api/private/agenda. Esta es la primera llamada que el componente hará al montarse.
Añadir un nuevo contacto: Cuando el usuario desee agregar un contacto, se activará la ruta POST /api/private/agenda/add con el contact_cedula en el cuerpo de la solicitud.
Eliminar un contacto: La ruta DELETE /api/private/agenda/:contact_cedula se usará para eliminar un contacto de la agenda del usuario.
Buscar contactos: El GET /api/private/agenda ya soporta un search query parameter, lo que nos permite implementar la funcionalidad de búsqueda directamente en este componente.
ContactDetailsModal.vue
Este será el componente más complejo, ya que consolidará toda la información y las acciones relacionadas con un solo contacto. Su lógica se basará en las siguientes rutas:
Obtener detalles: Al abrir el modal, se hará una llamada a GET /api/private/agenda/details/:cedula para obtener toda la información personalizada.
Guardar/Actualizar detalles: El formulario dentro del modal enviará los datos a POST /api/private/agenda/details. Tu controlador upsertContactDetails se encargará de crear o actualizar según corresponda.
Gestionar notas: Las notas se manejarán con POST /api/private/agenda/note. El upsertContactNote que creaste es perfecto para esto.
Manejo de eventos (Follow-ups):
Crear: POST /api/private/agenda/events.
Obtener: GET /api/private/agenda/events/:contact_cedula (para listar los eventos en el modal).
Eliminar: DELETE /api/private/agenda/events/:id.
Manejo de categorías:
Obtener categorías disponibles: GET /api/private/agenda/categories.
Asignar: POST /api/private/agenda/categories.
Obtener categorías asignadas: GET /api/private/agenda/categories/:contact_cedula.
Eliminar: DELETE /api/private/agenda/categories/:id.
Manejo de teléfonos personalizados:
Añadir: POST /api/private/agenda/telefono.
Eliminar: DELETE /api/private/agenda/telefono/:id.
Próximos Pasos en el Desarrollo
Con esta claridad en las rutas, podemos proceder con la implementación.
Empecemos con la vista de tabla: Diseñaremos el componente AgendaTable.vue que se encargará de mostrar la lista de contactos, el botón para agregar/quitar de la agenda y el botón para ver los detalles del contacto.
Lógica del Store: Crearemos un AgendaStore con Pinia para manejar el estado global de la aplicación. Este store tendrá las acciones para realizar las llamadas a la API que acabamos de mapear.
Implementación del Modal: Una vez que la tabla esté funcionando, construiremos el ContactDetailsModal.vue y sus sub-componentes para manejar los detalles, notas, eventos y categorías.
*******************
Componentes Visuales del Front-end
1. TheAgenda.vue
Es el componente principal o contenedor. Su función es orquestar todos los demás microcomponentes. Actúa como el cerebro de la aplicación, manejando el estado general, pasando datos (props) a los componentes hijos y escuchando eventos (emits) para actualizar la vista.
2. AgendaToolbar.vue
Este microcomponente es la barra de herramientas de la agenda. Su propósito es proporcionar las funcionalidades de búsqueda, filtrado por categoría y el botón para añadir nuevos contactos. Se comunica con TheAgenda.vue para que la vista principal pueda reaccionar a los cambios.
3. AgendaTable.vue
Es el componente de la tabla que muestra la lista de contactos. Su función es renderizar los datos que recibe del store de Pinia. También se encarga de:
Mostrar información clave como nombre, empresa y fechas de interacción.
Permitir la eliminación de contactos.
Mostrar tooltips para mejorar la usabilidad.
Manejar la lógica de filtrado por categoría y la búsqueda.
4. NewContactModal.vue
Este es un componente modal con un formulario. Su única función es permitir a los usuarios crear un nuevo contacto desde cero que no exista en la guía pública. Se encarga de la validación del formulario y de enviar los datos al store de Pinia para que sean guardados en el backend.
5. ContactDetailsModal.vue
Otro componente modal, pero este es mucho más complejo. Actúa como el panel de control para la información detallada de un contacto. Su función es:
Mostrar y permitir la edición de detalles personales (cargo, empresa, dirección, etc.).
Integrar otros microcomponentes para gestionar información específica.
6. ContactInfoEditor.vue
Un componente especializado diseñado para manejar los teléfonos y correos electrónicos de un contacto. Se encarga de:
Listar los teléfonos y correos existentes.
Proporcionar campos para añadir, editar y eliminar entradas.
Validar el formato del correo electrónico.
7. FollowupEvents.vue
Este componente se encarga de la gestión de eventos de seguimiento. Muestra un historial de interacciones pasadas y permite al usuario registrar nuevas interacciones o eventos de seguimiento futuros.
8. ContactCategories.vue
Finalmente, este componente gestiona las categorías o etiquetas de un contacto. Su función es permitir al usuario asociar un contacto a una o varias categorías predefinidas, o incluso crear nuevas categorías sobre la marcha.
Al dividir la interfaz de usuario en estos microcomponentes, logramos una estructura modular y mantenible. Cada componente tiene una responsabilidad clara, lo que hace que el código sea más fácil de entender, depurar y escalar en el futuro.
-------------

TABLAS RESUMEN.
Tabla: general - Campos: id, nombres, apellidos, completo, cedula
Tabla: telefonos - Campos: id, cedula_persona, numero, tipo, id_usuario
Tabla: user_agendas - Campos: user_id, contact_cedula, created_at, updated_at, tipo_relacion
Tabla: user_nombres - Campos: user_id, contact_cedula, nombre_personalizado
Tabla: user_telefonos - Campos: id, user_id, contact_cedula, numero, tipo
Tabla: contact_details - Campos: cedula, cargo, empresa, direccion, notas, fecha_nacimiento, es_padre, es_madre, created_at, updated_at, perfil_linkedin, area_negocio, user_id
Tabla: contact_notes - Campos: id, user_id, contact_cedula, titulo, cuerpo, fecha_nota
Tabla: follow_up_events - Campos: id, user_id, title, description, date, color, icon, created_at, updated_at, contact_cedula, event_key, contexto_interaccion, es_recordatorio
Tabla: categorias - Campos: id, nombre_categoria
Tabla: user_agenda_categorias - Campos: user_id, contact_cedula, categoria_id

INDEXES RESUMEN.
general_pkey: PRIMARY KEY on id 
idx_general_apellidos: BTREE index on apellidos
idx_general_cedula: BTREE index on cedula
idx_general_nombres: BTREE index on nombres
idx_general_search_vector: GIN index on search_vector
unique_cedula_constraint: UNIQUE CONSTRAINT on cedula
telefonos_pkey: PRIMARY KEY on id
idx_telefonos_cedula: BTREE index on cedula_persona
idx_telefonos_numero: BTREE index on numero
user_agendas_pkey: PRIMARY KEY on (user_id, contact_cedula)
idx_user_agendas_tipo_relacion: BTREE index on tipo_relacion
user_nombres_pkey: PRIMARY KEY on (user_id, contact_cedula)
user_telefonos_pkey: PRIMARY KEY on id
contact_details_pkey: PRIMARY KEY on (user_id, cedula)
idx_contact_details_area_negocio: BTREE index on area_negocio
contact_notes_pkey: PRIMARY KEY on id
follow_up_events_pkey: PRIMARY KEY on id
follow_up_events_event_key_key: UNIQUE CONSTRAINT on event_key
idx_follow_up_events_contact_cedula: BTREE index on contact_cedula
categorias_pkey: PRIMARY KEY on id
categorias_nombre_categoria_key: UNIQUE CONSTRAINT on nombre_categoria
user_agenda_categorias_pkey: PRIMARY KEY on (user_id, contact_cedula, categoria_id)
idx_user_agenda_categorias_categoria_id: BTREE index on categoria_id
idx_user_agenda_categorias_user_id: BTREE index on user_id

FOREIGN KEY RESUMEN
fk_general_created_by: La columna created_by hace referencia a la columna id de la tabla users.
fk_general_updated_by: La columna updated_by hace referencia a la columna id de la tabla users.
telefonos_cedula_persona_fkey: La columna cedula_persona hace referencia a la columna cedula de la tabla general.
fk_user_agenda_contact: La columna contact_cedula hace referencia a la columna cedula de la tabla general.
fk_user_agenda_user: La columna user_id hace referencia a la columna id de la tabla users.
fk_user_nombres: Las columnas (user_id, contact_cedula) hacen referencia a las columnas (user_id, contact_cedula) de la tabla user_agendas.
fk_user_telefonos: Las columnas (user_id, contact_cedula) hacen referencia a las columnas (user_id, contact_cedula) de la tabla user_agendas.
fk_cedula_contact_general: La columna cedula hace referencia a la columna cedula de la tabla general.
fk_user_contact_details: Las columnas (user_id, cedula) hacen referencia a las columnas (user_id, contact_cedula) de la tabla user_agendas.
fk_contact_notes: Las columnas (user_id, contact_cedula) hacen referencia a las columnas (user_id, contact_cedula) de la tabla user_agendas.
fk_follow_up_event_contact: Las columnas (user_id, contact_cedula) hacen referencia a las columnas (user_id, contact_cedula) de la tabla user_agendas.
follow_up_events_user_id_fkey: La columna user_id hace referencia a la columna id de la tabla users.
fk_user_agenda_categorias_categoria: La columna categoria_id hace referencia a la columna id de la tabla categorias.
fk_user_agenda_categorias_user: Las columnas (user_id, contact_cedula) hacen referencia a las columnas (user_id, contact_cedula) de la tabla user_agendas.

REFERENCES RESUMEN
A general: abogados, contact_details, despachantes,docentes,func_bnf,funcpublic,itaipu,user_agendas,yacyreta,telefonos,telefonos_historial
A user_agendas: contact_notes, follow_up_events, user_agenda_categorias, contact_details,user_nombres, user_telefonos
A categorias: user_agenda_categorias