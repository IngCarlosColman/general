    Tablas de la GuÃ­a TelefÃ³nica Global (Solo Lectura)
    Estas tablas son la fuente de datos principal y no pueden ser modificadas directamente por los usuarios desde su agenda personal.
    general: La tabla que contiene la informaciÃ³n bÃ¡sica y global de todas las personas (nombres, apellidos, cÃ©dula).
    telefonos: Almacena los nÃºmeros de telÃ©fono principales, asociados a los registros de la tabla general.
    Tablas de la Agenda Personal (Por Usuario)
    Estas tablas son el espacio personal de cada usuario. Los cambios que se hagan aquÃ­ solo afectarÃ¡n a su propia agenda, dejando intacta la informaciÃ³n de la guÃ­a telefÃ³nica global.
    user_agendas: La tabla central que conecta al user_id con el contacto (a travÃ©s de la contact_cedula). Es la que define quÃ© contactos de la guÃ­a telefÃ³nica pertenecen a la agenda de cada usuario.
    user_nombres: Guarda los nombres personalizados que cada usuario le asigne a un contacto.
    user_telefonos: Permite a cada usuario agregar y gestionar sus propios nÃºmeros de telÃ©fono para un contacto, de forma independiente de los nÃºmeros globales.
    contact_details: Almacena los detalles adicionales que el usuario personaliza, como el cargo, la empresa o el perfil de LinkedIn.
    contact_notes: Un historial detallado de las notas o interacciones que el usuario tiene con un contacto.
    follow_up_events: Se utiliza para los eventos de seguimiento y recordatorios (fecha, tÃ­tulo, etc.) que cada usuario crea para sus contactos.
    categorias: Contiene los nombres de las categorÃ­as que el usuario puede crear (por ejemplo, "Negocios", "Familia").
    user_agenda_categorias: Conecta a un contacto de la agenda de un usuario con una o varias categorÃ­as.
    ======================
    datos_ap-# \d+ general;
                                                                    Table "public.general"
        Column     |           Type           | Collation | Nullable |               Default               | Storage  | Compression | Stats target | Description
    ---------------+--------------------------+-----------+----------+-------------------------------------+----------+-------------+--------------+-------------
    id            | integer                  |           | not null | nextval('general_id_seq'::regclass) | plain    |             |              |
    nombres       | text                     |           |          |                                     | extended |             |              |
    apellidos     | text                     |           |          |                                     | extended |             |              |
    completo      | text                     |           |          |                                     | extended |             |              |
    cedula        | text                     |           |          |                                     | extended |             |              |
    search_vector | tsvector                 |           |          |                                     | extended |             |              |
    created_at    | timestamp with time zone |           | not null | now()                               | plain    |             |              |
    created_by    | integer                  |           |          |                                     | plain    |             |              |
    updated_at    | timestamp with time zone |           |          |                                     | plain    |             |              |
    updated_by    | integer                  |           |          |                                     | plain    |             |              |
    Indexes:
        "general_pkey" PRIMARY KEY, btree (id)
        "idx_general_apellidos" btree (apellidos)
        "idx_general_cedula" btree (cedula)
        "idx_general_nombres" btree (nombres)
        "idx_general_search_vector" gin (search_vector)
        "unique_cedula_constraint" UNIQUE CONSTRAINT, btree (cedula)
    Foreign-key constraints:
        "fk_general_created_by" FOREIGN KEY (created_by) REFERENCES users(id)
        "fk_general_updated_by" FOREIGN KEY (updated_by) REFERENCES users(id)
    Referenced by:
        TABLE "abogados" CONSTRAINT "fk_abogados_general" FOREIGN KEY (cedula) REFERENCES general(cedula) ON UPDATE CASCADE ON DELETE SET NULL
        TABLE "contact_details" CONSTRAINT "fk_cedula_contact_general" FOREIGN KEY (cedula) REFERENCES general(cedula) ON UPDATE CASCADE ON DELETE CASCADE
        TABLE "despachantes" CONSTRAINT "fk_despachantes_general" FOREIGN KEY (cedula) REFERENCES general(cedula) ON UPDATE CASCADE ON DELETE SET NULL
        TABLE "docentes" CONSTRAINT "fk_docentes_general" FOREIGN KEY (cedula) REFERENCES general(cedula) ON UPDATE CASCADE ON DELETE SET NULL
        TABLE "func_bnf" CONSTRAINT "fk_func_bnf_general" FOREIGN KEY (cedula) REFERENCES general(cedula) ON UPDATE CASCADE ON DELETE SET NULL
        TABLE "funcpublic" CONSTRAINT "fk_funcpublic_general" FOREIGN KEY (cedula) REFERENCES general(cedula) ON UPDATE CASCADE ON DELETE SET NULL
        TABLE "itaipu" CONSTRAINT "fk_itaipu_general" FOREIGN KEY (cedula) REFERENCES general(cedula) ON UPDATE CASCADE ON DELETE SET NULL
        TABLE "user_agendas" CONSTRAINT "fk_user_agenda_contact" FOREIGN KEY (contact_cedula) REFERENCES general(cedula) ON UPDATE CASCADE ON DELETE CASCADE
        TABLE "yacyreta" CONSTRAINT "fk_yacyreta_general" FOREIGN KEY (cedula) REFERENCES general(cedula) ON UPDATE CASCADE ON DELETE CASCADE
        TABLE "telefonos" CONSTRAINT "telefonos_cedula_persona_fkey" FOREIGN KEY (cedula_persona) REFERENCES general(cedula) ON DELETE CASCADE
        TABLE "telefonos_historial" CONSTRAINT "telefonos_historial_cedula_persona_fkey" FOREIGN KEY (cedula_persona) REFERENCES general(cedula) ON DELETE CASCADE
    Triggers:
        general_audit_trigger BEFORE UPDATE ON general FOR EACH ROW EXECUTE FUNCTION update_audit_fields()
        general_search_vector_update BEFORE INSERT OR UPDATE ON general FOR EACH ROW EXECUTE FUNCTION update_general_search_vector()
        trg_update_search_vector BEFORE INSERT OR UPDATE ON general FOR EACH ROW EXECUTE FUNCTION update_general_search_vector()
    Access method: heap
    datos_ap-# \d+ telefonos;
                                                            Table "public.telefonos"
        Column     |  Type   | Collation | Nullable |                Default                | Storage  | Compression | Stats target | Description
    ----------------+---------+-----------+----------+---------------------------------------+----------+-------------+--------------+-------------
    id             | integer |           | not null | nextval('telefonos_id_seq'::regclass) | plain    |             |              |
    cedula_persona | text    |           |          |                                       | extended |             |              |
    numero         | text    |           | not null |                                       | extended |             |              |
    tipo           | text    |           | not null |                                       | extended |             |              |
    id_usuario     | integer |           |          |                                       | plain    |             |              |
    Indexes:
        "telefonos_pkey" PRIMARY KEY, btree (id)
        "idx_telefonos_cedula" btree (cedula_persona)
        "idx_telefonos_numero" btree (numero)
    Foreign-key constraints:
        "telefonos_cedula_persona_fkey" FOREIGN KEY (cedula_persona) REFERENCES general(cedula) ON DELETE CASCADE
    Access method: heap
    datos_ap-# \d+ user_agendas;
                                                            Table "public.user_agendas"
        Column     |           Type           | Collation | Nullable |      Default      | Storage  | Compression | Stats target | Description
    ----------------+--------------------------+-----------+----------+-------------------+----------+-------------+--------------+-------------
    user_id        | integer                  |           | not null |                   | plain    |             |              |
    contact_cedula | text                     |           | not null |                   | extended |             |              |
    created_at     | timestamp with time zone |           |          | CURRENT_TIMESTAMP | plain    |             |              |
    updated_at     | timestamp with time zone |           |          | CURRENT_TIMESTAMP | plain    |             |              |
    tipo_relacion  | character varying(50)    |           |          |                   | extended |             |              |
    Indexes:
        "user_agendas_pkey" PRIMARY KEY, btree (user_id, contact_cedula)
        "idx_user_agendas_tipo_relacion" btree (tipo_relacion)
    Foreign-key constraints:
        "fk_user_agenda_contact" FOREIGN KEY (contact_cedula) REFERENCES general(cedula) ON UPDATE CASCADE ON DELETE CASCADE
        "fk_user_agenda_user" FOREIGN KEY (user_id) REFERENCES users(id) ON UPDATE CASCADE ON DELETE CASCADE
    Referenced by:
        TABLE "contact_notes" CONSTRAINT "contact_notes_user_id_contact_cedula_fkey" FOREIGN KEY (user_id, contact_cedula) REFERENCES user_agendas(user_id, contact_cedula) ON DELETE CASCADE
        TABLE "contact_notes" CONSTRAINT "fk_contact_notes" FOREIGN KEY (user_id, contact_cedula) REFERENCES user_agendas(user_id, contact_cedula) ON DELETE CASCADE
        TABLE "follow_up_events" CONSTRAINT "fk_follow_up_event_contact" FOREIGN KEY (user_id, contact_cedula) REFERENCES user_agendas(user_id, contact_cedula) ON DELETE CASCADE
        TABLE "user_agenda_categorias" CONSTRAINT "fk_user_agenda_categorias_user" FOREIGN KEY (user_id, contact_cedula) REFERENCES user_agendas(user_id, contact_cedula) ON DELETE CASCADE
        TABLE "contact_details" CONSTRAINT "fk_user_contact_details" FOREIGN KEY (user_id, cedula) REFERENCES user_agendas(user_id, contact_cedula) ON DELETE CASCADE
        TABLE "user_nombres" CONSTRAINT "fk_user_nombres" FOREIGN KEY (user_id, contact_cedula) REFERENCES user_agendas(user_id, contact_cedula) ON DELETE CASCADE
        TABLE "user_telefonos" CONSTRAINT "fk_user_telefonos" FOREIGN KEY (user_id, contact_cedula) REFERENCES user_agendas(user_id, contact_cedula) ON DELETE CASCADE
        TABLE "user_agenda_categorias" CONSTRAINT "user_agenda_categorias_user_id_contact_cedula_fkey" FOREIGN KEY (user_id, contact_cedula) REFERENCES user_agendas(user_id, contact_cedula) ON DELETE CASCADE
        TABLE "user_nombres" CONSTRAINT "user_nombres_user_id_contact_cedula_fkey" FOREIGN KEY (user_id, contact_cedula) REFERENCES user_agendas(user_id, contact_cedula) ON DELETE CASCADE
        TABLE "user_telefonos" CONSTRAINT "user_telefonos_user_id_contact_cedula_fkey" FOREIGN KEY (user_id, contact_cedula) REFERENCES user_agendas(user_id, contact_cedula) ON DELETE CASCADE
    Access method: heap
    datos_ap-# \d+ user_nombres;
                                                        Table "public.user_nombres"
            Column        |          Type          | Collation | Nullable | Default | Storage  | Compression | Stats target | Description
    ----------------------+------------------------+-----------+----------+---------+----------+-------------+--------------+-------------
    user_id              | integer                |           | not null |         | plain    |             |              |
    contact_cedula       | character varying(255) |           | not null |         | extended |             |              |
    nombre_personalizado | text                   |           | not null |         | extended |             |              |
    Indexes:
        "user_nombres_pkey" PRIMARY KEY, btree (user_id, contact_cedula)
    Foreign-key constraints:
        "fk_user_nombres" FOREIGN KEY (user_id, contact_cedula) REFERENCES user_agendas(user_id, contact_cedula) ON DELETE CASCADE
        "user_nombres_user_id_contact_cedula_fkey" FOREIGN KEY (user_id, contact_cedula) REFERENCES user_agendas(user_id, contact_cedula) ON DELETE CASCADE
    Access method: heap
    datos_ap-# \d+ user_telefonos;
                                                                    Table "public.user_telefonos"
        Column     |          Type          | Collation | Nullable |                  Default                   | Storage  | Compression | Stats target | Description
    ----------------+------------------------+-----------+----------+--------------------------------------------+----------+-------------+--------------+-------------
    id             | integer                |           | not null | nextval('user_telefonos_id_seq'::regclass) | plain    |             |              |
    user_id        | integer                |           | not null |                                            | plain    |             |              |
    contact_cedula | character varying(255) |           | not null |                                            | extended |             |              |
    numero         | text                   |           | not null |                                            | extended |             |              |
    tipo           | text                   |           |          |                                            | extended |             |              |
    Indexes:
        "user_telefonos_pkey" PRIMARY KEY, btree (id)
    Foreign-key constraints:
        "fk_user_telefonos" FOREIGN KEY (user_id, contact_cedula) REFERENCES user_agendas(user_id, contact_cedula) ON DELETE CASCADE
        "user_telefonos_user_id_contact_cedula_fkey" FOREIGN KEY (user_id, contact_cedula) REFERENCES user_agendas(user_id, contact_cedula) ON DELETE CASCADE
    Access method: heap
    datos_ap-# \d+ contact_details;
                                                            Table "public.contact_details"
        Column      |           Type           | Collation | Nullable |      Default      | Storage  | Compression | Stats target | Description
    ------------------+--------------------------+-----------+----------+-------------------+----------+-------------+--------------+-------------
    cedula           | character varying(255)   |           | not null |                   | extended |             |              |
    cargo            | character varying(255)   |           |          |                   | extended |             |              |
    empresa          | character varying(255)   |           |          |                   | extended |             |              |
    direccion        | text                     |           |          |                   | extended |             |              |
    notas            | text                     |           |          |                   | extended |             |              |
    fecha_nacimiento | date                     |           |          |                   | plain    |             |              |
    es_padre         | boolean                  |           |          | false             | plain    |             |              |
    es_madre         | boolean                  |           |          | false             | plain    |             |              |
    created_at       | timestamp with time zone |           |          | CURRENT_TIMESTAMP | plain    |             |              |
    updated_at       | timestamp with time zone |           |          | CURRENT_TIMESTAMP | plain    |             |              |
    perfil_linkedin  | character varying(255)   |           |          |                   | extended |             |              |
    area_negocio     | character varying(100)   |           |          |                   | extended |             |              |
    user_id          | integer                  |           | not null |                   | plain    |             |              |
    Indexes:
        "contact_details_pkey" PRIMARY KEY, btree (user_id, cedula)
        "idx_contact_details_area_negocio" btree (area_negocio)
    Foreign-key constraints:
        "fk_cedula_contact_general" FOREIGN KEY (cedula) REFERENCES general(cedula) ON UPDATE CASCADE ON DELETE CASCADE
        "fk_user_contact_details" FOREIGN KEY (user_id, cedula) REFERENCES user_agendas(user_id, contact_cedula) ON DELETE CASCADE
    Access method: heap
    datos_ap-# \d+ contact_notes;
                                                                        Table "public.contact_notes"
        Column     |           Type           | Collation | Nullable |                  Default                  | Storage  | Compression | Stats target | Description
    ----------------+--------------------------+-----------+----------+-------------------------------------------+----------+-------------+--------------+-------------
    id             | integer                  |           | not null | nextval('contact_notes_id_seq'::regclass) | plain    |             |              |
    user_id        | integer                  |           | not null |                                           | plain    |             |              |
    contact_cedula | character varying(255)   |           | not null |                                           | extended |             |              |
    titulo         | character varying(255)   |           | not null |                                           | extended |             |              |
    cuerpo         | text                     |           |          |                                           | extended |             |              |
    fecha_nota     | timestamp with time zone |           |          | CURRENT_TIMESTAMP                         | plain    |             |              |
    Indexes:
        "contact_notes_pkey" PRIMARY KEY, btree (id)
    Foreign-key constraints:
        "contact_notes_user_id_contact_cedula_fkey" FOREIGN KEY (user_id, contact_cedula) REFERENCES user_agendas(user_id, contact_cedula) ON DELETE CASCADE
        "fk_contact_notes" FOREIGN KEY (user_id, contact_cedula) REFERENCES user_agendas(user_id, contact_cedula) ON DELETE CASCADE
    Access method: heap
    datos_ap-# \d+ follow_up_events;
                                                                            Table "public.follow_up_events"
            Column        |            Type             | Collation | Nullable |                   Default                    | Storage  | Compression | Stats target | Description
    ----------------------+-----------------------------+-----------+----------+----------------------------------------------+----------+-------------+--------------+-------------
    id                   | integer                     |           | not null | nextval('follow_up_events_id_seq'::regclass) | plain    |             |              |
    user_id              | integer                     |           | not null |                                              | plain    |             |              |
    title                | character varying(255)      |           | not null |                                              | extended |             |              |
    description          | text                        |           |          |                                              | extended |             |              |
    date                 | timestamp without time zone |           | not null |                                              | plain    |             |              |
    color                | character varying(7)        |           |          | '#1565C0'::character varying                 | extended |             |              |
    icon                 | character varying(255)      |           |          | 'mdi-pencil'::character varying              | extended |             |              |
    created_at           | timestamp without time zone |           |          | CURRENT_TIMESTAMP                            | plain    |             |              |
    updated_at           | timestamp without time zone |           |          | CURRENT_TIMESTAMP                            | plain    |             |              |
    contact_cedula       | character varying(255)      |           |          |                                              | extended |             |              |
    event_key            | character varying(255)      |           |          |                                              | extended |             |              |
    contexto_interaccion | character varying(255)      |           |          |                                              | extended |             |              |
    es_recordatorio      | boolean                     |           |          | false                                        | plain    |             |              |
    Indexes:
        "follow_up_events_pkey" PRIMARY KEY, btree (id)
        "follow_up_events_event_key_key" UNIQUE CONSTRAINT, btree (event_key)
        "idx_follow_up_events_contact_cedula" btree (contact_cedula)
    Foreign-key constraints:
        "fk_follow_up_event_contact" FOREIGN KEY (user_id, contact_cedula) REFERENCES user_agendas(user_id, contact_cedula) ON DELETE CASCADE
        "follow_up_events_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
    Access method: heap
    datos_ap-# \d+ categorias;
                                                                    Table "public.categorias"
        Column      |         Type          | Collation | Nullable |                Default                 | Storage  | Compression | Stats target | Description
    ------------------+-----------------------+-----------+----------+----------------------------------------+----------+-------------+--------------+-------------
    id               | integer               |           | not null | nextval('categorias_id_seq'::regclass) | plain    |             |              |
    nombre_categoria | character varying(50) |           | not null |                                        | extended |             |              |
    Indexes:
        "categorias_pkey" PRIMARY KEY, btree (id)
        "categorias_nombre_categoria_key" UNIQUE CONSTRAINT, btree (nombre_categoria)
    Referenced by:
        TABLE "user_agenda_categorias" CONSTRAINT "fk_user_agenda_categorias_categoria" FOREIGN KEY (categoria_id) REFERENCES categorias(id) ON DELETE CASCADE
        TABLE "user_agenda_categorias" CONSTRAINT "user_agenda_categorias_categoria_id_fkey" FOREIGN KEY (categoria_id) REFERENCES categorias(id) ON DELETE CASCADE
    Access method: heap
    datos_ap=# \d+ user_agenda_categorias;
                                                Table "public.user_agenda_categorias"
        Column     |          Type          | Collation | Nullable | Default | Storage  | Compression | Stats target | Description
    ----------------+------------------------+-----------+----------+---------+----------+-------------+--------------+-------------
    user_id        | integer                |           | not null |         | plain    |             |              |
    contact_cedula | character varying(255) |           | not null |         | extended |             |              |
    categoria_id   | integer                |           | not null |         | plain    |             |              |
    Indexes:
        "user_agenda_categorias_pkey" PRIMARY KEY, btree (user_id, contact_cedula, categoria_id)
        "idx_user_agenda_categorias_categoria_id" btree (categoria_id)
        "idx_user_agenda_categorias_user_id" btree (user_id)
    Foreign-key constraints:
        "fk_user_agenda_categorias_categoria" FOREIGN KEY (categoria_id) REFERENCES categorias(id) ON DELETE CASCADE
        "fk_user_agenda_categorias_user" FOREIGN KEY (user_id, contact_cedula) REFERENCES user_agendas(user_id, contact_cedula) ON DELETE CASCADE
        "user_agenda_categorias_categoria_id_fkey" FOREIGN KEY (categoria_id) REFERENCES categorias(id) ON DELETE CASCADE
        "user_agenda_categorias_user_id_contact_cedula_fkey" FOREIGN KEY (user_id, contact_cedula) REFERENCES user_agendas(user_id, contact_cedula) ON DELETE CASCADE
    Access method: heap
    -------
1. como vamos a bautizar nuestro componente..
2. revisar los stores pinia existentes ... para determinar la creacion de uno particular para la agenda...
3. ver la vista de la guia telefonica de donde se va a optener los contactos.. para tratarlos de forma profesional en nuestra nueva aplicacion de agenda..
4. Discusiones de funcionalidades... para la vista.. y alineamiento de de la lÃ³gica..
5. diseÃ±o final y ajustes. para implementar.
----
1. Nombramiento del Componente
Para mantener la consistencia y la claridad en tu proyecto, es crucial nombrar los componentes de forma descriptiva. Siguiendo las convenciones de Vue/Pinia y la lÃ³gica de tu aplicaciÃ³n, sugiero el siguiente nombre:
TheAgenda.vue: Este es un nombre simple, directo y profesional. "The" le da un sentido de ser el componente principal para esa funcionalidad. Alternativamente, podrÃ­as usar UserAgenda.vue para enfatizar que es una agenda personal por usuario, pero TheAgenda es mÃ¡s conciso y claro en el contexto de tu aplicaciÃ³n.
2. RevisiÃ³n de Stores Pinia
Actualmente, no tienes un store de Pinia dedicado a la agenda. Crear uno es la mejor opciÃ³n. Esto te permitirÃ¡ gestionar el estado de manera centralizada, lo que es esencial para funcionalidades como:
Lista de Contactos de la Agenda: Un store puede almacenar y gestionar la lista de contactos que el usuario ha agregado a su agenda personal.
GestiÃ³n de Eventos y CategorÃ­as: Un store puede manejar la lÃ³gica para agregar, eliminar y actualizar eventos de seguimiento, asÃ­ como la asignaciÃ³n de categorÃ­as.
SincronizaciÃ³n de Datos: El store se encargarÃ¡ de llamar a los endpoints del backend que acabamos de crear (/api/private-agenda/*) y de mantener los datos actualizados en la interfaz de usuario.
El nombre propuesto para el store es useAgendaStore.js.
3. Vista de la GuÃ­a TelefÃ³nica
La vista de la guÃ­a telefÃ³nica (GeneralData) es el punto de partida clave. El flujo de trabajo para que un usuario agregue un contacto a su agenda personal serÃ¡ el siguiente:
En la vista GeneralData: El usuario verÃ¡ la lista completa de contactos de la tabla general.
BotÃ³n de AcciÃ³n: Cada fila de la tabla deberÃ¡ tener un botÃ³n (por ejemplo, con un Ã­cono de "agregar a la agenda" o una estrella) que permita al usuario agregar ese contacto a su agenda personal.
LÃ³gica del Evento: Al hacer clic en este botÃ³n, se debe disparar una acciÃ³n que llame a tu nuevo useAgendaStore. Este store, a su vez, harÃ¡ una solicitud POST al endpoint /api/private-agenda/agenda/add con la cÃ©dula del contacto.
Esto garantiza una separaciÃ³n de responsabilidades: el componente de la guÃ­a telefÃ³nica se encarga de mostrar los datos, y el store de la agenda se encarga de la lÃ³gica de negocio para agregar el contacto.
4. DiscusiÃ³n de Funcionalidades y Alineamiento LÃ³gico
Esta es la fase de diseÃ±o. Consideremos las funcionalidades clave y cÃ³mo se alinean con tu backend:
Vista Principal de la Agenda: DeberÃ¡ ser una tabla o una lista de contactos. Cada contacto debe mostrar su nombre (el personalizado si existe, si no el de la guÃ­a general), su cÃ©dula y una lista de sus telÃ©fonos (los personales si existen, y si no, los globales).
Detalles del Contacto: Al hacer clic en un contacto, se debe abrir un modal o una vista lateral con pestaÃ±as que muestren:
InformaciÃ³n BÃ¡sica: El nombre personalizado, cargo, empresa, etc. (controlador contactDetailsController).
TelÃ©fonos: La lista de telÃ©fonos personales (controlador userTelefonosController).
Notas: Un campo de texto para notas personales (controlador contactNotesController).
CategorÃ­as: Una secciÃ³n para asignar y mostrar categorÃ­as (controlador userCategoriesController).
Historial de Seguimiento: La lista de eventos de seguimiento con la fecha y las notas (controlador followupEventsController).
Cada una de estas pestaÃ±as se comunicarÃ¡ con su respectivo endpoint del backend para cargar, crear, actualizar o eliminar datos.
5. DiseÃ±o Final y Ajustes para la ImplementaciÃ³n
Una vez que la lÃ³gica anterior estÃ© clara, el diseÃ±o de la interfaz de usuario se harÃ¡ mucho mÃ¡s fÃ¡cil.
Estructura del Componente: El componente TheAgenda.vue contendrÃ¡ la tabla principal. UtilizarÃ¡s componentes secundarios para los modales o vistas de detalle de cada contacto. Por ejemplo, ContactDetailModal.vue, que a su vez contendrÃ¡ ContactPhones.vue, ContactNotes.vue, etc.
ComposiciÃ³n de la Interfaz: UsarÃ¡s componentes de tu biblioteca de UI (como Vuetify) para las tablas, botones, formularios y modales, lo que acelerarÃ¡ el desarrollo y mantendrÃ¡ la consistencia visual.
Este plan te darÃ¡ un componente de agenda robusto, profesional y, sobre todo, seguro, ya que cada acciÃ³n estarÃ¡ respaldada por la lÃ³gica del backend que has construido.
----
de los 5 puntos
vamos a realizar uno a uno...
cuando estemos satisfechos e indiquemos que finalizamos todo pasemos al siguiente punto hasta finalizar.. hagamos organiizadamente..
-----
----
Estudio Inicial
1. InformaciÃ³n de contacto
Nombre completo: Nombre y apellido del contacto.
NÃºmero(s) de telÃ©fono: Puedes tener varios (celular, casa, trabajo). Es Ãºtil categorizarlos.
Correo electrÃ³nico: Un campo para uno o mÃ¡s correos.
DirecciÃ³n: Calle, nÃºmero, ciudad, cÃ³digo postal, etc. Esto puede ser Ãºtil para la geolocalizaciÃ³n o para envÃ­o de correspondencia.
Empresa y cargo: Si el contacto es profesional, estos datos son muy relevantes.
RelaciÃ³n: Puedes aÃ±adir un campo para saber quÃ© tipo de relaciÃ³n tienes con la persona (amigo, familiar, colega, cliente, etc.). Esto puede ayudar a organizar y filtrar tus contactos.
2. InformaciÃ³n complementari
Notas personales: Un campo de texto largo para aÃ±adir cualquier tipo de nota que no encaje en las otras categorÃ­as (por ejemplo, "Le gusta el cafÃ©", "CumpleaÃ±os en noviembre", "ReuniÃ³n de seguimiento programada").
Fecha de cumpleaÃ±os o aniversario: Esto es Ãºtil para recibir recordatorios y fechas importantes.
Etiquetas o categorÃ­as: Permite etiquetar los contactos para agruparlos de manera mÃ¡s flexible, por ejemplo, "Proyecto A", "Futbol", "Familia". Esto facilitarÃ¡ mucho las bÃºsquedas y filtros.
Foto de perfil: Una imagen pequeÃ±a del contacto.
3. Aspectos tÃ©cnicos y de diseÃ±o
ID del contacto: Un identificador Ãºnico (ID) para cada registro en tu base de datos.
Fecha de adiciÃ³n: La fecha en que el contacto fue aÃ±adido a tu agenda personal.
Fecha de Ãºltima modificaciÃ³n: La fecha en que se actualizÃ³ por Ãºltima vez la informaciÃ³n del contacto.
Ãcono de estrella: Para la funcionalidad que mencionas, la estrella, puedes usarla como un toggle que actualiza un campo en la base de datos de la guÃ­a telefÃ³nica. PodrÃ­as llamarlo es_favorito o en_agenda_personal, con un valor booleano (true/false). Al presionar el Ã­cono, el contacto se "copia" o, mejor aÃºn, se asocia a la agenda personal del usuario.
----- Avanzado
Campos de Contacto Esenciales
Estos campos te permiten capturar la informaciÃ³n fundamental de un contacto profesional.
InformaciÃ³n de la Persona:
Nombre Completo (nombre, apellidos).
Cargo/Puesto (cargo).
Empresa/OrganizaciÃ³n (empresa).
Ãrea de Negocio (por ejemplo, "Finanzas", "Marketing", "Recursos Humanos").
Datos de Contacto:
TelÃ©fonos (pueden ser varios: telÃ©fono_oficina, celular, etc.).
Correo ElectrÃ³nico (email_profesional, email_personal).
DirecciÃ³n de la Oficina.
Perfil de LinkedIn/Red Profesional.
Anotaciones y Seguimiento (La Clave de una Agenda Profesional)
AquÃ­ es donde tu agenda se convierte en una herramienta estratÃ©gica.
Notas de InteracciÃ³n: Un campo de texto (notas) para registrar los detalles de tus interacciones.
"Llamada el 15/09/2025 para discutir la propuesta del proyecto X."
"ReuniÃ³n con el equipo el 18/09/2025. Juan Carlos se mostrÃ³ interesado en la fase 2."
Fecha de Ãšltima InteracciÃ³n: Un campo automÃ¡tico que registre la Ãºltima vez que te comunicaste con el contacto. Esto es vital para saber cuÃ¡ndo necesitas retomar el contacto.
PrÃ³ximo Seguimiento: Un campo para programar la prÃ³xima vez que te pondrÃ¡s en contacto con la persona. Por ejemplo, "Llamar en 3 semanas para dar seguimiento al presupuesto."
Contexto de la RelaciÃ³n: Un campo para indicar cÃ³mo conociste al contacto (por ejemplo, "Conferencia de IT 2025", "Recomendado por Pedro LÃ³pez").
RelaciÃ³n Clave: Marca el tipo de relaciÃ³n profesional: Cliente, Socio, Proveedor, Colega, Inversor, etc. Esto te permite filtrar y organizar tu red.
Eventos y Tareas Relacionadas: Crea tareas o eventos especÃ­ficos vinculados al contacto (por ejemplo, "Enviar propuesta", "Preparar presentaciÃ³n").
Campos Adicionales y Funcionalidades
Para un nivel mÃ¡s avanzado, considera:
Etiquetas Personalizadas: Permite a los usuarios crear sus propias etiquetas, como Proyecto Alpha, Networking, Potencial Socio, para una organizaciÃ³n aÃºn mÃ¡s granular.
Fechas Importantes: AdemÃ¡s del cumpleaÃ±os, puedes incluir la fecha de su aniversario en la empresa o la fecha de la firma de un contrato importante.
------
Con los detalles que me has proporcionado, que incluyen la estructura de las tablas, los campos avanzados y las funcionalidades deseadas, el camino para construir la interfaz perfecta para TheAgenda.vue estÃ¡ muy claro. La clave es diseÃ±ar una interfaz que no solo muestre los datos, sino que tambiÃ©n facilite el flujo de trabajo del usuario para que la agenda sea una herramienta estratÃ©gica, no solo una lista de contactos.
Mi propuesta se basa en un diseÃ±o modular y enfocado en la usabilidad, aprovechando la separaciÃ³n de responsabilidades que ya tienes en tus tablas.
1. Vista Principal: TheAgenda.vue
El diseÃ±o principal debe ser limpio y funcional, mostrando una lista de contactos que sea fÃ¡cil de navegar y filtrar. Un diseÃ±o con una lista de tarjetas (V-Card) o una tabla de datos compacta es la mejor opciÃ³n. Sugiero usar una tabla con capacidades de bÃºsqueda y filtrado.
Tabla de Contactos: Similar a la guÃ­a telefÃ³nica, pero mostrando solo los contactos de la agenda del usuario.
Columnas Clave: Muestra los datos mÃ¡s relevantes de un vistazo: Nombre Completo, Empresa, Cargo, TelÃ©fono Principal (el que el usuario haya marcado como principal en su agenda), Ãšltima InteracciÃ³n y PrÃ³ximo Seguimiento.
Acciones RÃ¡pidas: En cada fila, iconos de acciÃ³n rÃ¡pida para las tareas mÃ¡s comunes:
ðŸ“ž Llamar: Un icono de telÃ©fono para la acciÃ³n openWhatsApp o similar.
â­ Desafiar: Un icono de estrella (mdi-star) que, al hacer clic, elimina el contacto de la agenda personal.
ðŸ“ Notas: Un icono para agregar una nueva nota.
ðŸ—“ï¸ Seguimiento: Un icono para programar un evento de seguimiento.
Barra de Herramientas Superior:
Buscador Global: Un campo de bÃºsqueda que filtre por todos los campos visibles (nombre, empresa, cargo, etc.).
Filtros Inteligentes: Botones o un menÃº desplegable para filtrar por las categorÃ­as personalizadas del usuario (user_agenda_categorias). Por ejemplo: "Clientes", "Familia", "Proyecto X".
BotÃ³n de AdiciÃ³n: Aunque los contactos se agregan desde la guÃ­a, un botÃ³n de "AÃ±adir contacto nuevo" permitirÃ­a al usuario agregar personas que no estÃ©n en la guÃ­a pÃºblica. Esto activarÃ­a un formulario modal.
2. Formulario de Detalles del Contacto (Modal)
Cuando el usuario haga clic en un contacto de la tabla, se debe abrir un modal o un panel lateral que muestre todos los detalles. Este modal debe ser el centro de la interacciÃ³n y la personalizaciÃ³n. La interfaz debe ser intuitiva y visualmente atractiva, con secciones para cada tipo de informaciÃ³n.
PestaÃ±as/Secciones: El modal se dividirÃ­a en pestaÃ±as o secciones para no sobrecargar al usuario:
InformaciÃ³n General:
Datos Principales: Muestra el nombre completo, cargo, empresa y los datos que provienen de las tablas general y contact_details.
EdiciÃ³n Personalizada: Los campos de la tabla user_nombres, user_telefonos, y contact_details deben ser editables. Por ejemplo, el usuario podrÃ­a cambiar el nombre de "Juan PÃ©rez" a "Juanito (Cliente)".
CategorÃ­as: Un campo de etiquetas (V-Chip) para asignar y desasignar categorÃ­as personalizadas (categorias).
Notas y Seguimiento:
Historial de Notas: Una lista ordenada cronolÃ³gicamente de todas las notas de la tabla contact_notes. Cada nota deberÃ­a tener una fecha y un tÃ­tulo. Un botÃ³n de "Nueva Nota" permitirÃ­a aÃ±adir un nuevo registro.
PrÃ³ximos Eventos: Una lista de los prÃ³ximos eventos o recordatorios de la tabla follow_up_events. Un botÃ³n de "AÃ±adir Seguimiento" abrirÃ­a un pequeÃ±o formulario para crear un nuevo evento.
Archivos y Documentos:
Esta funcionalidad, aunque no la mencionaste, podrÃ­a ser una adiciÃ³n avanzada. Un Ã¡rea para adjuntar documentos relevantes (contratos, propuestas) asociados al contacto. Esto usarÃ­a una tabla tipo contact_documents.
// src/controllers/contactDetails.controller.js
const { pool } = require('../db/db');
/**
Â * Crea o actualiza los detalles de un contacto en la agenda personal del usuario.
Â * Utiliza un "upsert" para simplificar la lÃ³gica.
Â * @param {object} req - Objeto de solicitud de Express.
Â * @param {object} res - Objeto de respuesta de Express.
Â */
const upsertContactDetails = async (req, res) => {
Â  Â  const { cedula, cargo, empresa, direccion, fecha_nacimiento, perfil_linkedin, area_negocio } = req.body;
Â  Â  const { id: user_id } = req.user;
Â  Â  if (!cedula) {
Â  Â  Â  Â  return res.status(400).json({ error: 'La cÃ©dula del contacto es requerida.' });
Â  Â  }
Â  Â  try {
Â  Â  Â  Â  const query = `
Â  Â  Â  Â  Â  Â  INSERT INTO contact_details (user_id, cedula, cargo, empresa, direccion, fecha_nacimiento, perfil_linkedin, area_negocio)
Â  Â  Â  Â  Â  Â  VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
Â  Â  Â  Â  Â  Â  ON CONFLICT (user_id, cedula) DO UPDATE SET
Â  Â  Â  Â  Â  Â  Â  Â  cargo = EXCLUDED.cargo,
Â  Â  Â  Â  Â  Â  Â  Â  empresa = EXCLUDED.empresa,
Â  Â  Â  Â  Â  Â  Â  Â  direccion = EXCLUDED.direccion,
Â  Â  Â  Â  Â  Â  Â  Â  fecha_nacimiento = EXCLUDED.fecha_nacimiento,
Â  Â  Â  Â  Â  Â  Â  Â  perfil_linkedin = EXCLUDED.perfil_linkedin,
Â  Â  Â  Â  Â  Â  Â  Â  area_negocio = EXCLUDED.area_negocio,
Â  Â  Â  Â  Â  Â  Â  Â  updated_at = NOW()
Â  Â  Â  Â  Â  Â  RETURNING *;
Â  Â  Â  Â  `;
Â  Â  Â  Â  const result = await pool.query(query, [user_id, cedula, cargo, empresa, direccion, fecha_nacimiento, perfil_linkedin, area_negocio]);
Â  Â  Â  Â  res.status(200).json(result.rows[0]);
Â  Â  } catch (err) {
Â  Â  Â  Â  console.error('Error al crear o actualizar los detalles del contacto:', err);
Â  Â  Â  Â  res.status(500).json({ error: 'Error del servidor.', details: err.detail });
Â  Â  }
};
/**
Â * Obtiene los detalles personalizados de un contacto especÃ­fico del usuario.
Â * @param {object} req - Objeto de solicitud de Express.
Â * @param {object} res - Objeto de respuesta de Express.
Â */
const getContactDetails = async (req, res) => {
Â  Â  const { cedula } = req.params;
Â  Â  const { id: user_id } = req.user;
Â  Â  try {
Â  Â  Â  Â  const query = `
Â  Â  Â  Â  Â  Â  SELECT *
Â  Â  Â  Â  Â  Â  FROM contact_details
Â  Â  Â  Â  Â  Â  WHERE user_id = $1 AND cedula = $2;
Â  Â  Â  Â  `;
Â  Â  Â  Â  const result = await pool.query(query, [user_id, cedula]);
Â  Â  Â  Â  if (result.rowCount === 0) {
Â  Â  Â  Â  Â  Â  return res.status(404).json({ error: 'Detalles del contacto no encontrados.' });
Â  Â  Â  Â  }
Â  Â  Â  Â  res.json(result.rows[0]);
Â  Â  } catch (err) {
Â  Â  Â  Â  console.error('Error al obtener los detalles del contacto:', err);
Â  Â  Â  Â  res.status(500).json({ error: 'Error del servidor.', details: err.detail });
Â  Â  }
};
module.exports = {
Â  Â  upsertContactDetails,
Â  Â  getContactDetails,
};
-
// src/controllers/contactNotes.controller.js
const { pool } = require('../db/db');
/**
Â * Crea o actualiza una nota para un contacto en la agenda del usuario.
Â * @param {object} req - Objeto de solicitud de Express.
Â * @param {object} res - Objeto de respuesta de Express.
Â */
const upsertContactNote = async (req, res) => {
Â  Â  const { contact_cedula, nota } = req.body;
Â  Â  const { id: user_id } = req.user;
Â  Â  if (!contact_cedula || !nota) {
Â  Â  Â  Â  return res.status(400).json({ error: 'La cÃ©dula del contacto y la nota son requeridas.' });
Â  Â  }
Â  Â  try {
Â  Â  Â  Â  const query = `
Â  Â  Â  Â  Â  Â  INSERT INTO contact_notes (user_id, contact_cedula, nota)
Â  Â  Â  Â  Â  Â  VALUES ($1, $2, $3)
Â  Â  Â  Â  Â  Â  ON CONFLICT (user_id, contact_cedula) DO UPDATE SET
Â  Â  Â  Â  Â  Â  Â  Â  nota = EXCLUDED.nota,
Â  Â  Â  Â  Â  Â  Â  Â  updated_at = NOW()
Â  Â  Â  Â  Â  Â  RETURNING *;
Â  Â  Â  Â  `;
Â  Â  Â  Â  const result = await pool.query(query, [user_id, contact_cedula, nota]);
Â  Â  Â  Â  res.status(200).json(result.rows[0]);
Â  Â  } catch (err) {
Â  Â  Â  Â  console.error('Error al guardar la nota:', err);
Â  Â  Â  Â  res.status(500).json({ error: 'Error del servidor.', details: err.detail });
Â  Â  }
};
module.exports = {
Â  Â  upsertContactNote,
};
-
// src/controllers/followupEvents.controller.js
const { pool } = require('../db/db');
/**
Â * Crea un nuevo evento de seguimiento para un contacto.
Â * @param {object} req - Objeto de solicitud de Express.
Â * @param {object} res - Objeto de respuesta de Express.
Â */
const createFollowupEvent = async (req, res) => {
Â  Â  const { contact_cedula, tipo_evento, fecha, notas } = req.body;
Â  Â  const { id: user_id } = req.user;
Â  Â  if (!contact_cedula || !tipo_evento || !fecha) {
Â  Â  Â  Â  return res.status(400).json({ error: 'La cÃ©dula, tipo de evento y fecha son requeridos.' });
Â  Â  }
Â  Â  try {
Â  Â  Â  Â  const query = `
Â  Â  Â  Â  Â  Â  INSERT INTO follow_up_events (user_id, contact_cedula, tipo_evento, fecha, notas)
Â  Â  Â  Â  Â  Â  VALUES ($1, $2, $3, $4, $5)
Â  Â  Â  Â  Â  Â  RETURNING *;
Â  Â  Â  Â  `;
Â  Â  Â  Â  const result = await pool.query(query, [user_id, contact_cedula, tipo_evento, fecha, notas]);
Â  Â  Â  Â  res.status(201).json(result.rows[0]);
Â  Â  } catch (err) {
Â  Â  Â  Â  console.error('Error al crear el evento de seguimiento:', err);
Â  Â  Â  Â  res.status(500).json({ error: 'Error del servidor.', details: err.detail });
Â  Â  }
};
/**
Â * Obtiene todos los eventos de seguimiento para un contacto especÃ­fico,
Â * que pertenecen al usuario autenticado.
Â * @param {object} req - Objeto de solicitud de Express.
Â * @param {object} res - Objeto de respuesta de Express.
Â */
const getFollowupEventsByContact = async (req, res) => {
Â  Â  const { contact_cedula } = req.params;
Â  Â  const { id: user_id } = req.user;
Â Â  try {
Â  Â  Â  Â  const query = `
Â  Â  Â  Â  Â  Â  SELECT * FROM follow_up_events
Â  Â  Â  Â  Â  Â  WHERE user_id = $1 AND contact_cedula = $2
Â  Â  Â  Â  Â  Â  ORDER BY fecha DESC;
Â  Â  Â  Â  `;
Â  Â  Â  Â  const result = await pool.query(query, [user_id, contact_cedula]);
Â  Â  Â  Â  res.json(result.rows);
Â  Â  } catch (err) {
Â  Â  Â  Â  console.error('Error al obtener los eventos de seguimiento:', err);
Â  Â  Â  Â  res.status(500).json({ error: 'Error del servidor.', details: err.detail });
Â  Â  }
};
/**
Â * Elimina un evento de seguimiento. Solo el creador puede eliminarlo.
Â * @param {object} req - Objeto de solicitud de Express.
Â * @param {object} res - Objeto de respuesta de Express.
Â */
const deleteFollowupEvent = async (req, res) => {
Â  Â  const { id } = req.params;
Â  Â  const { id: user_id } = req.user;
Â  Â  try {
Â  Â  Â  Â  const query = `
Â  Â  Â  Â  Â  Â  DELETE FROM follow_up_events
Â  Â  Â  Â  Â  Â  WHERE id = $1 AND user_id = $2
Â  Â  Â  Â  Â  Â  RETURNING *;
Â  Â  Â  Â  `;
Â  Â  Â  Â  const result = await pool.query(query, [id, user_id]);
Â  Â  Â  Â  if (result.rowCount === 0) {
Â  Â  Â  Â  Â  Â  return res.status(404).json({ error: 'Evento no encontrado o no tienes permiso para eliminarlo.' });
Â  Â  Â  Â  } Â  Â  
Â  Â  Â  Â  res.status(200).json({ message: 'Evento eliminado correctamente.' });
Â  Â  } catch (err) {
Â  Â  Â  Â  console.error('Error al eliminar el evento:', err);
Â  Â  Â  Â  res.status(500).json({ error: 'Error del servidor.', details: err.detail });
Â  Â  }
};
module.exports = {
Â  Â  createFollowupEvent,
Â  Â  getFollowupEventsByContact,
Â  Â  deleteFollowupEvent,
};
-
const { pool } = require('../db/db');
const { upsertGeneral } = require('./general.controller'); 
/**
Â * Agrega un contacto a la agenda privada del usuario.
Â */
const addContactToAgenda = async (req, res) => {
Â  Â  const { id: userId } = req.user;
Â  Â  const { contactCedula } = req.body;
Â  Â  const client = await pool.connect();
Â  Â  try {
Â  Â  Â  Â  await client.query('BEGIN');
Â  Â  Â  Â  // Insertar el contacto en la agenda del usuario
Â  Â  Â  Â  const insertQuery = `
Â  Â  Â  Â  Â  Â  INSERT INTO user_agendas (user_id, contact_cedula)
Â  Â  Â  Â  Â  Â  VALUES ($1, $2)
Â  Â  Â  Â  Â  Â  RETURNING *;
Â  Â  Â  Â  `;
Â  Â  Â  Â  const result = await client.query(insertQuery, [userId, contactCedula]);
Â  Â  Â  Â  await client.query('COMMIT');
Â  Â  Â  Â  res.status(201).json({ message: 'Contacto agregado a la agenda privada.', contact: result.rows[0] });
Â  Â  } catch (err) {
Â  Â  Â  Â  await client.query('ROLLBACK');
Â  Â  Â  Â  console.error('Error al agregar contacto a la agenda privada:', err);
Â  Â  Â  Â  if (err.code === '23505') { // Error de clave duplicada
Â  Â  Â  Â  Â  Â  res.status(409).json({ error: 'El contacto ya estÃ¡ en tu agenda privada.', details: err.detail });
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  res.status(500).json({ error: 'Error del servidor.', details: err.detail });
Â  Â  Â  Â  }
Â  Â  } finally {
Â  Â  Â  Â  client.release();
Â  Â  }
};
/**
Â * Obtiene solo la lista de cÃ©dulas de la agenda privada del usuario.
Â */
const getPrivateAgendaCedulas = async (req, res) => {
Â  Â  const { id: userId } = req.user;
Â  Â  try {
Â  Â  Â  Â  const query = `
Â  Â  Â  Â  Â  Â  SELECT contact_cedula
Â  Â  Â  Â  Â  Â  FROM user_agendas
Â  Â  Â  Â  Â  Â  WHERE user_id = $1;
Â  Â  Â  Â  `;
Â  Â  Â  Â  const result = await pool.query(query, [userId]);
Â  Â  Â  Â  const cedulas = result.rows.map(row => row.contact_cedula);
Â  Â  Â  Â  res.json(cedulas);
Â  Â  } catch (err) {
Â  Â  Â  Â  console.error('Error al obtener las cÃ©dulas de la agenda privada:', err);
Â  Â  Â  Â  res.status(500).json({ error: 'Error del servidor' });
Â  Â  }
};
/**
Â * Obtiene la lista completa de contactos de la agenda privada del usuario.
Â */
const getPrivateAgenda = async (req, res) => {
Â  Â  const { id: userId } = req.user;
Â  Â  const { page = 1, itemsPerPage = 10, search = '' } = req.query;
Â  Â  const limit = Math.min(parseInt(itemsPerPage), 100);
Â  Â  const offset = (parseInt(page) - 1) * limit;
Â  Â  let whereClause = `WHERE ua.user_id = $1`;
Â  Â  const queryParams = [userId];
Â  Â  let paramIndex = 2;
Â  Â  if (search) {
Â  Â  Â  Â  const searchTerms = search.split(/\s+/).filter(term => term);
Â  Â  Â  Â  if (searchTerms.length > 0) {
Â  Â  Â  Â  Â  Â  whereClause += ` AND g.search_vector @@ to_tsquery('spanish', $${paramIndex})`;
Â  Â  Â  Â  Â  Â  queryParams.push(searchTerms.map(t => `${t}:*`).join(' & '));
Â  Â  Â  Â  Â  Â  paramIndex++;
Â  Â  Â  Â  }
Â  Â  }
Â  Â  try {
Â  Â  Â  Â  const countQuery = `SELECT COUNT(*) FROM user_agendas ua JOIN general g ON ua.contact_cedula = g.cedula ${whereClause}`;
Â  Â  Â  Â  const countResult = await pool.query(countQuery, queryParams);
Â  Â  Â  Â  const totalItems = parseInt(countResult.rows[0].count);
Â  Â  Â  Â  const dataQuery = `
Â  Â  Â  Â  Â  Â  SELECT
Â  Â  Â  Â  Â  Â  Â  Â  ua.contact_cedula AS cedula,
Â  Â  Â  Â  Â  Â  Â  Â  g.nombres,
Â  Â  Â  Â  Â  Â  Â  Â  g.apellidos,
Â  Â  Â  Â  Â  Â  Â  Â  g.completo,
Â  Â  Â  Â  Â  Â  Â  Â  cd.cargo,
Â  Â  Â  Â  Â  Â  Â  Â  cd.empresa,
Â  Â  Â  Â  Â  Â  Â  Â  cd.direccion,
Â  Â  Â  Â  Â  Â  Â  Â  cd.notas,
Â  Â  Â  Â  Â  Â  Â  Â  cd.fecha_nacimiento,
Â  Â  Â  Â  Â  Â  Â  Â  cd.es_padre,
Â  Â  Â  Â  Â  Â  Â  Â  cd.es_madre,
Â  Â  Â  Â  Â  Â  Â  Â  json_agg(t.numero) FILTER (WHERE t.numero IS NOT NULL) AS telefonos
Â  Â  Â  Â  Â  Â  FROM
Â  Â  Â  Â  Â  Â  Â  Â  user_agendas ua
Â  Â  Â  Â  Â  Â  JOIN
Â  Â  Â  Â  Â  Â  Â  Â  general g ON ua.contact_cedula = g.cedula
Â  Â  Â  Â  Â  Â  LEFT JOIN
Â  Â  Â  Â  Â  Â  Â  Â  contact_details cd ON ua.contact_cedula = cd.cedula
Â  Â  Â  Â  Â  Â  LEFT JOIN
Â  Â  Â  Â  Â  Â  Â  Â  telefonos t ON g.cedula = t.cedula_persona
Â  Â  Â  Â  Â  Â  ${whereClause}
Â  Â  Â  Â  Â  Â  GROUP BY
Â  Â  Â  Â  Â  Â  Â  Â  ua.contact_cedula, g.nombres, g.apellidos, g.completo, cd.cedula
Â  Â  Â  Â  Â  Â  ORDER BY
Â  Â  Â  Â  Â  Â  Â  Â  g.nombres ASC
Â  Â  Â  Â  Â  Â  LIMIT $${paramIndex} OFFSET $${paramIndex + 1};
Â  Â  Â  Â  `;
Â  Â  Â  Â  queryParams.push(limit);
Â  Â  Â  Â  queryParams.push(offset);
Â  Â  Â  Â  const dataResult = await pool.query(dataQuery, queryParams);
Â  Â  Â  Â  const items = dataResult.rows;
Â  Â  Â  Â  res.json({ items, totalItems });
Â  Â  } catch (err) {
Â  Â  Â  Â  console.error('Error al obtener la agenda privada:', err);
Â  Â  Â  Â  res.status(500).json({ error: 'Error del servidor' });
Â  Â  }
};
/**
Â * Actualiza los detalles de un contacto en la tabla 'contact_details'.
Â */
const updateContactDetails = async (req, res) => {
Â  Â  const { contactCedula } = req.params;
Â  Â  const { cargo, empresa, direccion, notas, fechaNacimiento, esPadre, esMadre } = req.body;
Â  Â  try {
Â  Â  Â  Â  // Verificar si el contacto existe en la agenda del usuario
Â  Â  Â  Â  const agendaCheck = await pool.query('SELECT user_id FROM user_agendas WHERE user_id = $1 AND contact_cedula = $2', [req.user.id, contactCedula]);
Â  Â  Â  Â  if (agendaCheck.rowCount === 0) {
Â  Â  Â  Â  Â  Â  return res.status(403).json({ error: 'No tienes permiso para editar este contacto o no existe en tu agenda.' });
Â  Â  Â  Â  }
Â  Â  Â  Â  const query = `
Â  Â  Â  Â  Â  Â  INSERT INTO contact_details (
Â  Â  Â  Â  Â  Â  Â  Â  cedula, cargo, empresa, direccion, notas, fecha_nacimiento, es_padre, es_madre, updated_at
Â  Â  Â  Â  Â  Â  ) VALUES (
Â  Â  Â  Â  Â  Â  Â  Â  $1, $2, $3, $4, $5, $6, $7, $8, NOW()
Â  Â  Â  Â  Â  Â  )
Â  Â  Â  Â  Â  Â  ON CONFLICT (cedula) DO UPDATE SET
Â  Â  Â  Â  Â  Â  Â  Â  cargo = EXCLUDED.cargo,
Â  Â  Â  Â  Â  Â  Â  Â  empresa = EXCLUDED.empresa,
Â  Â  Â  Â  Â  Â  Â  Â  direccion = EXCLUDED.direccion,
Â  Â  Â  Â  Â  Â  Â  Â  notas = EXCLUDED.notas,
Â  Â  Â  Â  Â  Â  Â  Â  fecha_nacimiento = EXCLUDED.fecha_nacimiento,
Â  Â  Â  Â  Â  Â  Â  Â  es_padre = EXCLUDED.es_padre,
Â  Â  Â  Â  Â  Â  Â  Â  es_madre = EXCLUDED.es_madre,
Â  Â  Â  Â  Â  Â  Â  Â  updated_at = NOW()
Â  Â  Â  Â  Â  Â  RETURNING *;
Â  Â  Â  Â  `;
Â  Â  Â  Â  const values = [contactCedula, cargo, empresa, direccion, notas, fechaNacimiento, esPadre, esMadre];
Â  Â  Â  Â  const result = await pool.query(query, values);Â  Â 
Â  Â  Â  Â  res.json({ message: 'Detalles del contacto actualizados.', updatedRecord: result.rows[0] });
Â  Â  } catch (err) {
Â  Â  Â  Â  console.error('Error al actualizar detalles del contacto:', err);
Â  Â  Â  Â  res.status(500).json({ error: 'Error del servidor', details: err.detail });
Â  Â  }
};
/**
Â * Elimina un contacto de la agenda privada de un usuario.
Â * TambiÃ©n limpia los detalles del contacto si ya no estÃ¡ en la agenda de ningÃºn otro usuario.
Â */
const deleteContactFromAgenda = async (req, res) => {
Â  Â  const { contactCedula } = req.params;
Â  Â  const { id: userId } = req.user;
Â  Â  const client = await pool.connect();
Â  Â  try {
Â  Â  Â  Â  await client.query('BEGIN');
Â  Â  Â  Â  // Paso 1: Eliminar el contacto de la agenda privada del usuario
Â  Â  Â  Â  const deleteAgendaQuery = `
Â  Â  Â  Â  Â  Â  DELETE FROM user_agendas
Â  Â  Â  Â  Â  Â  WHERE user_id = $1 AND contact_cedula = $2
Â  Â  Â  Â  Â  Â  RETURNING *;
Â  Â  Â  Â  `;
Â  Â  Â  Â  const result = await client.query(deleteAgendaQuery, [userId, contactCedula]);
Â  Â  Â  Â  if (result.rowCount === 0) {
Â  Â  Â  Â  Â  Â  await client.query('ROLLBACK');
Â  Â  Â  Â  Â  Â  return res.status(404).json({ error: 'El contacto no se encontrÃ³ en tu agenda privada.' });
Â  Â  Â  Â  }
Â  Â  Â  Â  // Paso 2: Verificar si el contacto aÃºn existe en la agenda de otro usuario
Â  Â  Â  Â  const checkOthersQuery = `
Â  Â  Â  Â  Â  Â  SELECT 1
Â  Â  Â  Â  Â  Â  FROM user_agendas
Â  Â  Â  Â  Â  Â  WHERE contact_cedula = $1
Â  Â  Â  Â  Â  Â  LIMIT 1;
Â  Â  Â  Â  `;
Â  Â  Â  Â  const othersResult = await client.query(checkOthersQuery, [contactCedula]);
Â  Â  Â  Â  // Si no se encontraron otros registros, es seguro eliminar los detalles del contacto
Â  Â  Â  Â  if (othersResult.rowCount === 0) {
Â  Â  Â  Â  Â  Â  const deleteDetailsQuery = `
Â  Â  Â  Â  Â  Â  Â  Â  DELETE FROM contact_details
Â  Â  Â  Â  Â  Â  Â  Â  WHERE cedula = $1
Â  Â  Â  Â  Â  Â  Â  Â  RETURNING *;
Â  Â  Â  Â  Â  Â  `;
Â  Â  Â  Â  Â  Â  await client.query(deleteDetailsQuery, [contactCedula]);
Â  Â  Â  Â  Â  Â  console.log(`Detalles del contacto ${contactCedula} eliminados porque ya no estÃ¡ en la agenda de ningÃºn usuario.`);
Â  Â  Â  Â  }Â  Â  Â  
Â  Â  Â  Â  await client.query('COMMIT');
Â  Â  Â  Â  res.json({ message: 'Contacto eliminado de la agenda exitosamente.', deletedRecord: result.rows[0] });
Â  Â  } catch (err) {
Â  Â  Â  Â  await client.query('ROLLBACK');
Â  Â  Â  Â  console.error('Error al eliminar contacto de la agenda:', err);
Â  Â  Â  Â  res.status(500).json({ error: 'Error del servidor', details: err.detail });
Â  Â  } finally {
Â  Â  Â  Â  client.release();
Â  Â  }
};
module.exports = {
Â  Â  addContactToAgenda,
Â  Â  getPrivateAgenda,
Â  Â  getPrivateAgendaCedulas,
Â  Â  updateContactDetails,
Â  Â  deleteContactFromAgenda,
};
----
// src/controllers/userAgenda.controller.js
const { pool } = require('../db/db');
/**
Â * Agrega un contacto de la guÃ­a global a la agenda personal de un usuario.
Â * @param {object} req - Objeto de solicitud de Express.
Â * @param {object} res - Objeto de respuesta de Express.
Â */
const addContactToAgenda = async (req, res) => {
Â  Â  const { contact_cedula } = req.body;
Â  Â  const { id: user_id } = req.user;
Â  Â  if (!contact_cedula) {
Â  Â  Â  Â  return res.status(400).json({ error: 'La cÃ©dula del contacto es requerida.' });
Â  Â  }
Â  Â  try {
Â  Â  Â  Â  // Paso 1: Insertar el contacto en la tabla principal `user_agendas`.
Â  Â  Â  Â  // Esta es la operaciÃ³n obligatoria para establecer el vÃ­nculo.
Â  Â  Â  Â  // Se utiliza ON CONFLICT para manejar duplicados de manera eficiente.
Â  Â  Â  Â  const insertAgendaQuery = `
Â  Â  Â  Â  Â  Â  INSERT INTO user_agendas (user_id, contact_cedula)
Â  Â  Â  Â  Â  Â  VALUES ($1, $2)
Â  Â  Â  Â  Â  Â  ON CONFLICT (user_id, contact_cedula) DO NOTHING
Â  Â  Â  Â  Â  Â  RETURNING *;
Â  Â  Â  Â  `;
Â  Â  Â  Â  const agendaResult = await pool.query(insertAgendaQuery, [user_id, contact_cedula]);
Â  Â  Â  Â  // Si el contacto ya existÃ­a y no se hizo una inserciÃ³n (rowCount === 0), salimos.
Â  Â  Â  Â  if (agendaResult.rowCount === 0) {
Â  Â  Â  Â  Â  Â  return res.status(409).json({ message: 'El contacto ya existe en tu agenda.' });
Â  Â  Â  Â  }
Â  Â  Â  Â  // Paso 2: Obtener los datos del contacto de la tabla `general` para la respuesta.
Â  Â  Â  Â  const generalContactQuery = `
Â  Â  Â  Â  Â  Â  SELECT g.completo, t.telefonos
Â  Â  Â  Â  Â  Â  FROM general g
Â  Â  Â  Â  Â  Â  LEFT JOIN mv_telefonos_agregados t ON g.cedula = t.cedula
Â  Â  Â  Â  Â  Â  WHERE g.cedula = $1;
Â  Â  Â  Â  `;
Â  Â  Â  Â  const generalContactResult = await pool.query(generalContactQuery, [contact_cedula]);
Â  Â  Â  Â  if (generalContactResult.rows.length === 0) {
Â  Â  Â  Â  Â  Â  // Esto es una validaciÃ³n de seguridad.
Â  Â  Â  Â  Â  Â  return res.status(404).json({ error: 'Contacto no encontrado en la guÃ­a general.' });
Â  Â  Â  Â  } Â  
Â  Â  Â  Â  const { completo, telefonos } = generalContactResult.rows[0];
Â  Â  Â  Â  // Se prepara el objeto de respuesta con los datos de la guÃ­a global.
Â  Â  Â  Â  const newContact = {
Â  Â  Â  Â  Â  Â  contact_cedula: contact_cedula,
Â  Â  Â  Â  Â  Â  nombre_completo: completo,
Â  Â  Â  Â  Â  Â  telefonos: telefonos,
Â  Â  Â  Â  };
Â  Â  Â  Â  res.status(201).json({ message: 'Contacto agregado a la agenda personal.', data: newContact });
Â  Â  } catch (err) {
Â  Â  Â  Â  console.error('Error al agregar contacto a la agenda personal:', err);
Â  Â  Â  Â  res.status(500).json({ error: 'Error del servidor.', details: err.detail });
Â  Â  }
};
/**
Â * Obtiene todos los contactos de la agenda personal de un usuario.
Â * @param {object} req - Objeto de solicitud de Express.
Â * @param {object} res - Objeto de respuesta de Express.
Â */
const getMyAgendaContacts = async (req, res) => {
Â  Â  const { id: user_id } = req.user;
Â  Â  try {
Â  Â  Â  Â  const query = `
Â  Â  Â  Â  Â  Â  SELECT
Â  Â  Â  Â  Â  Â  Â  Â  ua.contact_cedula,
Â  Â  Â  Â  Â  Â  Â  Â  COALESCE(unn.nombre_personalizado, g.completo) AS nombre_completo,
Â  Â  Â  Â  Â  Â  Â  Â  COALESCE(ut.telefonos, t.telefonos) AS telefonos,
Â  Â  Â  Â  Â  Â  Â  Â  ua.created_at
Â  Â  Â  Â  Â  Â  FROM
Â  Â  Â  Â  Â  Â  Â  Â  user_agendas ua
Â  Â  Â  Â  Â  Â  LEFT JOIN
Â  Â  Â  Â  Â  Â  Â  Â  general g ON ua.contact_cedula = g.cedula
Â  Â  Â  Â  Â  Â  LEFT JOIN
Â  Â  Â  Â  Â  Â  Â  Â  mv_telefonos_agregados t ON g.cedula = t.cedula
Â  Â  Â  Â  Â  Â  LEFT JOIN
Â  Â  Â  Â  Â  Â  Â  Â  user_nombres unn ON ua.user_id = unn.user_id AND ua.contact_cedula = unn.contact_cedula
Â  Â  Â  Â  Â  Â  LEFT JOIN
Â  Â  Â  Â  Â  Â  Â  Â  (
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  SELECT
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  user_id,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  contact_cedula,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  json_agg(numero) AS telefonos
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  FROM
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  user_telefonos
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  WHERE
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  user_id = $1
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  GROUP BY
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  user_id, contact_cedula
Â  Â  Â  Â  Â  Â  Â  Â  ) ut ON ua.user_id = ut.user_id AND ua.contact_cedula = ut.contact_cedula
Â  Â  Â  Â  Â  Â  WHERE
Â  Â  Â  Â  Â  Â  Â  Â  ua.user_id = $1
Â  Â  Â  Â  Â  Â  ORDER BY
Â  Â  Â  Â  Â  Â  Â  Â  nombre_completo ASC;
Â  Â  Â  Â  `;
Â  Â  Â  Â  const result = await pool.query(query, [user_id]);
Â  Â  Â  Â  res.json(result.rows);
Â  Â  } catch (err) {
Â  Â  Â  Â  console.error('Error al obtener la agenda del usuario:', err);
Â  Â  Â  Â  res.status(500).json({ error: 'Error del servidor.', details: err.detail });
Â  Â  }
};
/**
Â * Elimina un contacto de la agenda personal de un usuario.
Â * @param {object} req - Objeto de solicitud de Express.
Â * @param {object} res - Objeto de respuesta de Express.
Â */
const removeContactFromAgenda = async (req, res) => {
Â  Â  const { contact_cedula } = req.params;
Â  Â  const { id: user_id } = req.user;
Â  Â  try {
Â  Â  Â  Â  const query = `
Â  Â  Â  Â  Â  Â  DELETE FROM user_agendas
Â  Â  Â  Â  Â  Â  WHERE user_id = $1 AND contact_cedula = $2
Â  Â  Â  Â  Â  Â  RETURNING *;
Â  Â  Â  Â  `;
Â  Â  Â  Â  const result = await pool.query(query, [user_id, contact_cedula]);
Â  Â  Â  Â  if (result.rowCount === 0) {
Â  Â  Â  Â  Â  Â  return res.status(404).json({ error: 'El contacto no se encontrÃ³ en tu agenda.' });
Â  Â  Â  Â  }
Â  Â  Â  Â  res.json({ message: 'Contacto eliminado de tu agenda.' });
Â  Â  } catch (err) {
Â  Â  Â  Â  console.error('Error al eliminar contacto de la agenda:', err);
Â  Â  Â  Â  res.status(500).json({ error: 'Error del servidor.', details: err.detail });
Â  Â  }
};
module.exports = {
Â  Â  addContactToAgenda,
Â  Â  getMyAgendaContacts,
Â  Â  removeContactFromAgenda,
};
---
// src/controllers/userCategories.controller.js
const { pool } = require('../db/db');
/**
Â * Obtiene todas las categorÃ­as predefinidas.
Â * Estas categorÃ­as pueden ser creadas y gestionadas por un rol con permisos elevados (ej. administrador).
Â * @param {object} req - Objeto de solicitud de Express.
Â * @param {object} res - Objeto de respuesta de Express.
Â */
const getPredefinedCategories = async (req, res) => {
Â  Â  try {
Â  Â  Â  Â  const query = 'SELECT id, nombre, created_at FROM categorias ORDER BY nombre ASC;';
Â  Â  Â  Â  const result = await pool.query(query);
Â  Â  Â  Â  res.json(result.rows);
Â  Â  } catch (err) {
Â  Â  Â  Â  console.error('Error al obtener las categorÃ­as predefinidas:', err);
Â  Â  Â  Â  res.status(500).json({ error: 'Error del servidor.', details: err.detail });
Â  Â  }
};
/**
Â * Asigna una categorÃ­a a un contacto en la agenda personal de un usuario.
Â * @param {object} req - Objeto de solicitud de Express.
Â * @param {object} res - Objeto de respuesta de Express.
Â */
const assignCategoryToContact = async (req, res) => {
Â  Â  const { contact_cedula, categoria_id } = req.body;
Â  Â  const { id: user_id } = req.user;
Â  Â  if (!contact_cedula || !categoria_id) {
Â  Â  Â  Â  return res.status(400).json({ error: 'La cÃ©dula del contacto y el ID de la categorÃ­a son requeridos.' });
Â  Â  }
Â  Â  try {
Â  Â  Â  Â  const query = `
Â  Â  Â  Â  Â  Â  INSERT INTO user_agenda_categorias (user_id, contact_cedula, categoria_id)
Â  Â  Â  Â  Â  Â  VALUES ($1, $2, $3)
Â  Â  Â  Â  Â  Â  ON CONFLICT (user_id, contact_cedula, categoria_id) DO NOTHING
Â  Â  Â  Â  Â  Â  RETURNING *;
Â  Â  Â  Â  `;
Â  Â  Â  Â  const result = await pool.query(query, [user_id, contact_cedula, categoria_id]);
Â  Â  Â  Â  if (result.rowCount === 0) {
Â  Â  Â  Â  Â  Â  return res.status(409).json({ message: 'La categorÃ­a ya estÃ¡ asignada a este contacto.' });
Â  Â  Â  Â  }
Â  Â  Â  Â  res.status(201).json(result.rows[0]);
Â  Â  } catch (err) {
Â  Â  Â  Â  console.error('Error al asignar la categorÃ­a al contacto:', err);
Â  Â  Â  Â  res.status(500).json({ error: 'Error del servidor.', details: err.detail });
Â  Â  }
};
/**
Â * Obtiene las categorÃ­as asignadas a un contacto especÃ­fico de un usuario.
Â * @param {object} req - Objeto de solicitud de Express.
Â * @param {object} res - Objeto de respuesta de Express.
Â */
const getCategoriesByContact = async (req, res) => {
Â  Â  const { contact_cedula } = req.params;
Â  Â  const { id: user_id } = req.user;
Â  Â  try {
Â  Â  Â  Â  const query = `
Â  Â  Â  Â  Â  Â  SELECT
Â  Â  Â  Â  Â  Â  Â  Â  uac.id,
Â  Â  Â  Â  Â  Â  Â  Â  uac.categoria_id,
Â  Â  Â  Â  Â  Â  Â  Â  c.nombre AS nombre_categoria
Â  Â  Â  Â  Â  Â  FROM
Â  Â  Â  Â  Â  Â  Â  Â  user_agenda_categorias uac
Â  Â  Â  Â  Â  Â  JOIN
Â  Â  Â  Â  Â  Â  Â  Â  categorias c ON uac.categoria_id = c.id
Â  Â  Â  Â  Â  Â  WHERE
Â  Â  Â  Â  Â  Â  Â  Â  uac.user_id = $1 AND uac.contact_cedula = $2;
Â  Â  Â  Â  `;
Â  Â  Â  Â  const result = await pool.query(query, [user_id, contact_cedula]);
Â  Â  Â  Â  res.json(result.rows);
Â  Â  } catch (err) {
Â  Â  Â  Â  console.error('Error al obtener las categorÃ­as del contacto:', err);
Â  Â  Â  Â  res.status(500).json({ error: 'Error del servidor.', details: err.detail });
Â  Â  }
};
/**
Â * Elimina una categorÃ­a de un contacto.
Â * @param {object} req - Objeto de solicitud de Express.
Â * @param {object} res - Objeto de respuesta de Express.
Â */
const removeCategoryFromContact = async (req, res) => {
Â  Â  const { id } = req.params;
Â  Â  const { id: user_id } = req.user;
Â  Â  try {
Â  Â  Â  Â  const query = `
Â  Â  Â  Â  Â  Â  DELETE FROM user_agenda_categorias
Â  Â  Â  Â  Â  Â  WHERE id = $1 AND user_id = $2
Â  Â  Â  Â  Â  Â  RETURNING *;
Â  Â  Â  Â  `;
Â  Â  Â  Â  const result = await pool.query(query, [id, user_id]);
Â  Â  Â  Â  if (result.rowCount === 0) {
Â  Â  Â  Â  Â  Â  return res.status(404).json({ error: 'AsignaciÃ³n de categorÃ­a no encontrada o no tienes permiso para eliminarla.' });
Â  Â  Â  Â  }
Â  Â  Â  Â  res.status(200).json({ message: 'CategorÃ­a eliminada del contacto correctamente.' });
Â  Â  } catch (err) {
Â  Â  Â  Â  console.error('Error al eliminar la categorÃ­a del contacto:', err);
Â  Â  Â  Â  res.status(500).json({ error: 'Error del servidor.', details: err.detail });
Â  Â  }
};
module.exports = {
Â  Â  getPredefinedCategories,
Â  Â  assignCategoryToContact,
Â  Â  getCategoriesByContact,
Â  Â  removeCategoryFromContact,
};
---
// src/controllers/userNombres.controller.js
const { pool } = require('../db/db');
/**
Â * Crea o actualiza un nombre personalizado para un contacto en la agenda del usuario.
Â * @param {object} req - Objeto de solicitud de Express.
Â * @param {object} res - Objeto de respuesta de Express.
Â */
const upsertUserNombre = async (req, res) => {
Â  Â  const { contact_cedula, nombre_personalizado } = req.body;
Â  Â  const { id: user_id } = req.user;
Â  Â  if (!contact_cedula || !nombre_personalizado) {
Â  Â  Â  Â  return res.status(400).json({ error: 'La cÃ©dula y el nombre personalizado son requeridos.' });
Â  Â  }
Â  Â  try {
Â  Â  Â  Â  const query = `
Â  Â  Â  Â  Â  Â  INSERT INTO user_nombres (user_id, contact_cedula, nombre_personalizado)
Â  Â  Â  Â  Â  Â  VALUES ($1, $2, $3)
Â  Â  Â  Â  Â  Â  ON CONFLICT (user_id, contact_cedula) DO UPDATE SET
Â  Â  Â  Â  Â  Â  Â  Â  nombre_personalizado = EXCLUDED.nombre_personalizado,
Â  Â  Â  Â  Â  Â  Â  Â  updated_at = NOW()
Â  Â  Â  Â  Â  Â  RETURNING *;
Â  Â  Â  Â  `;
Â  Â  Â  Â  const result = await pool.query(query, [user_id, contact_cedula, nombre_personalizado]);
Â  Â  Â  Â  res.status(200).json(result.rows[0]);
Â  Â  } catch (err) {
Â  Â  Â  Â  console.error('Error al guardar el nombre personalizado:', err);
Â  Â  Â  Â  res.status(500).json({ error: 'Error del servidor.', details: err.detail });
Â  Â  }
};
module.exports = {
Â  Â  upsertUserNombre,
};
----
// src/controllers/userTelefonos.controller.js
const { pool } = require('../db/db');
/**
Â * Agrega un nuevo nÃºmero de telÃ©fono personal a un contacto de la agenda.
Â * @param {object} req - Objeto de solicitud de Express.
Â * @param {object} res - Objeto de respuesta de Express.
Â */
const addUserTelefono = async (req, res) => {
Â  Â  const { contact_cedula, numero } = req.body;
Â  Â  const { id: user_id } = req.user;
Â  Â  if (!contact_cedula || !numero) {
Â  Â  Â  Â  return res.status(400).json({ error: 'La cÃ©dula y el nÃºmero de telÃ©fono son requeridos.' });
Â  Â  }
Â  Â  try {
Â  Â  Â  Â  const query = `
Â  Â  Â  Â  Â  Â  INSERT INTO user_telefonos (user_id, contact_cedula, numero)
Â  Â  Â  Â  Â  Â  VALUES ($1, $2, $3)
Â  Â  Â  Â  Â  Â  ON CONFLICT (user_id, numero) DO NOTHING
Â  Â  Â  Â  Â  Â  RETURNING *;
Â  Â  Â  Â  `;
Â  Â  Â  Â  const result = await pool.query(query, [user_id, contact_cedula, numero]);
Â  Â  Â  Â  if (result.rowCount === 0) {
Â  Â  Â  Â  Â  Â  return res.status(409).json({ message: 'El nÃºmero de telÃ©fono ya existe para este contacto en tu agenda.' });
Â  Â  Â  Â  }
Â  Â  Â  Â  res.status(201).json(result.rows[0]);
Â  Â  } catch (err) {
Â  Â  Â  Â  console.error('Error al agregar telÃ©fono personal:', err);
Â  Â  Â  Â  res.status(500).json({ error: 'Error del servidor.', details: err.detail });
Â  Â  }
};
/**
Â * Elimina un nÃºmero de telÃ©fono personal de un contacto de la agenda.
Â * @param {object} req - Objeto de solicitud de Express.
Â * @param {object} res - Objeto de respuesta de Express.
Â */
const removeUserTelefono = async (req, res) => {
Â  Â  const { id } = req.params; // El ID del registro en user_telefonos
Â  Â  const { id: user_id } = req.user;
Â  Â  try {
Â  Â  Â  Â  const query = `
Â  Â  Â  Â  Â  Â  DELETE FROM user_telefonos
Â  Â  Â  Â  Â  Â  WHERE id = $1 AND user_id = $2
Â  Â  Â  Â  Â  Â  RETURNING *;
Â  Â  Â  Â  `;
Â  Â  Â  Â  const result = await pool.query(query, [id, user_id]);
Â  Â  Â  Â  if (result.rowCount === 0) {
Â  Â  Â  Â  Â  Â  return res.status(404).json({ error: 'TelÃ©fono no encontrado o no tienes permiso para eliminarlo.' });
Â  Â  Â  Â  }
Â  Â  Â  Â  res.status(200).json({ message: 'TelÃ©fono eliminado correctamente.' });
Â  Â  } catch (err) {
Â  Â  Â  Â  console.error('Error al eliminar telÃ©fono personal:', err);
Â  Â  Â  Â  res.status(500).json({ error: 'Error del servidor.', details: err.detail });
Â  Â  }
};
module.exports = {
Â  Â  addUserTelefono,
Â  Â  removeUserTelefono,
};
-
// src/routes/privateAgenda.routes.js
const express = require('express');
const router = express.Router();
// Importar todos los controladores de la agenda personal
const userAgendaController = require('../controllers/userAgenda.controller');
const contactDetailsController = require('../controllers/contactDetails.controller');
const userNombresController = require('../controllers/userNombres.controller');
const userTelefonosController = require('../controllers/userTelefonos.controller');
const contactNotesController = require('../controllers/contactNotes.controller');
const followupEventsController = require('../controllers/followupEvents.controller');
const userCategoriesController = require('../controllers/userCategories.controller');
// Importar los middlewares de autenticaciÃ³n y autorizaciÃ³n
const { authenticateJWT } = require('../middlewares/auth.middleware');
// Aplicar el middleware de autenticaciÃ³n a todas las rutas de la agenda privada
router.use(authenticateJWT);
// --- Rutas para la Agenda Personal (user_agendas) ---
// Obtener todos los contactos de la agenda del usuario
router.get('/agenda', userAgendaController.getMyAgendaContacts);
// AÃ±adir un contacto de la tabla 'general' a la agenda del usuario
router.post('/agenda/add', userAgendaController.addContactToAgenda);
// Eliminar un contacto de la agenda del usuario
router.delete('/agenda/:contact_cedula', userAgendaController.removeContactFromAgenda);
// --- Rutas para los Detalles del Contacto (contact_details) ---
// Crear o actualizar detalles personalizados de un contacto
router.post('/agenda/details', contactDetailsController.upsertContactDetails);
// Obtener los detalles personalizados de un contacto especÃ­fico
router.get('/agenda/details/:cedula', contactDetailsController.getContactDetails);
// --- Rutas para los Nombres Personalizados (user_nombres) ---
// Crear o actualizar un nombre personalizado para un contacto
router.post('/agenda/nombre', userNombresController.upsertUserNombre);
// Agregar un telÃ©fono personal a un contacto
router.post('/agenda/telefono', userTelefonosController.addUserTelefono);
// Eliminar un telÃ©fono personal de un contacto
router.delete('/agenda/telefono/:id', userTelefonosController.removeUserTelefono);
router.post('/agenda/note', contactNotesController.upsertContactNote);
router.post('/agenda/events', followupEventsController.createFollowupEvent);
// Obtener todos los eventos para un contacto
router.get('/agenda/events/:contact_cedula', followupEventsController.getFollowupEventsByContact);
// Eliminar un evento de seguimiento por ID
router.delete('/agenda/events/:id', followupEventsController.deleteFollowupEvent);
// Obtener la lista de categorÃ­as predefinidas
router.get('/agenda/categories', userCategoriesController.getPredefinedCategories);
// Asignar una categorÃ­a a un contacto
router.post('/agenda/categories', userCategoriesController.assignCategoryToContact);
// Obtener las categorÃ­as de un contacto especÃ­fico
router.get('/agenda/categories/:contact_cedula', userCategoriesController.getCategoriesByContact);
// Eliminar una categorÃ­a de un contacto
router.delete('/agenda/categories/:id', userCategoriesController.removeCategoryFromContact);
module.exports = router;
----
Mapeo de Endpoints y Funcionalidades
A continuaciÃ³n, se detalla el plan de integraciÃ³n para cada micro-componente, basÃ¡ndonos en las rutas que definiste:
TheAgenda.vue (Orquestador principal)
Este componente principal se encargarÃ¡ de:
Obtener la lista de contactos: UtilizarÃ¡ el endpoint GET /api/private/agenda. Esta es la primera llamada que el componente harÃ¡ al montarse.
AÃ±adir un nuevo contacto: Cuando el usuario desee agregar un contacto, se activarÃ¡ la ruta POST /api/private/agenda/add con el contact_cedula en el cuerpo de la solicitud.
Eliminar un contacto: La ruta DELETE /api/private/agenda/:contact_cedula se usarÃ¡ para eliminar un contacto de la agenda del usuario.
Buscar contactos: El GET /api/private/agenda ya soporta un search query parameter, lo que nos permite implementar la funcionalidad de bÃºsqueda directamente en este componente.
ContactDetailsModal.vue
Este serÃ¡ el componente mÃ¡s complejo, ya que consolidarÃ¡ toda la informaciÃ³n y las acciones relacionadas con un solo contacto. Su lÃ³gica se basarÃ¡ en las siguientes rutas:
Obtener detalles: Al abrir el modal, se harÃ¡ una llamada a GET /api/private/agenda/details/:cedula para obtener toda la informaciÃ³n personalizada.
Guardar/Actualizar detalles: El formulario dentro del modal enviarÃ¡ los datos a POST /api/private/agenda/details. Tu controlador upsertContactDetails se encargarÃ¡ de crear o actualizar segÃºn corresponda.
Gestionar notas: Las notas se manejarÃ¡n con POST /api/private/agenda/note. El upsertContactNote que creaste es perfecto para esto.
Manejo de eventos (Follow-ups):
Crear: POST /api/private/agenda/events.
Obtener: GET /api/private/agenda/events/:contact_cedula (para listar los eventos en el modal).
Eliminar: DELETE /api/private/agenda/events/:id.
Manejo de categorÃ­as:
Obtener categorÃ­as disponibles: GET /api/private/agenda/categories.
Asignar: POST /api/private/agenda/categories.
Obtener categorÃ­as asignadas: GET /api/private/agenda/categories/:contact_cedula.
Eliminar: DELETE /api/private/agenda/categories/:id.
Manejo de telÃ©fonos personalizados:
AÃ±adir: POST /api/private/agenda/telefono.
Eliminar: DELETE /api/private/agenda/telefono/:id.
PrÃ³ximos Pasos en el Desarrollo
Con esta claridad en las rutas, podemos proceder con la implementaciÃ³n.
Empecemos con la vista de tabla: DiseÃ±aremos el componente AgendaTable.vue que se encargarÃ¡ de mostrar la lista de contactos, el botÃ³n para agregar/quitar de la agenda y el botÃ³n para ver los detalles del contacto.
LÃ³gica del Store: Crearemos un AgendaStore con Pinia para manejar el estado global de la aplicaciÃ³n. Este store tendrÃ¡ las acciones para realizar las llamadas a la API que acabamos de mapear.
ImplementaciÃ³n del Modal: Una vez que la tabla estÃ© funcionando, construiremos el ContactDetailsModal.vue y sus sub-componentes para manejar los detalles, notas, eventos y categorÃ­as.
*******************
Componentes Visuales del Front-end
1. TheAgenda.vue
Es el componente principal o contenedor. Su funciÃ³n es orquestar todos los demÃ¡s microcomponentes. ActÃºa como el cerebro de la aplicaciÃ³n, manejando el estado general, pasando datos (props) a los componentes hijos y escuchando eventos (emits) para actualizar la vista.
2. AgendaToolbar.vue
Este microcomponente es la barra de herramientas de la agenda. Su propÃ³sito es proporcionar las funcionalidades de bÃºsqueda, filtrado por categorÃ­a y el botÃ³n para aÃ±adir nuevos contactos. Se comunica con TheAgenda.vue para que la vista principal pueda reaccionar a los cambios.
3. AgendaTable.vue
Es el componente de la tabla que muestra la lista de contactos. Su funciÃ³n es renderizar los datos que recibe del store de Pinia. TambiÃ©n se encarga de:
Mostrar informaciÃ³n clave como nombre, empresa y fechas de interacciÃ³n.
Permitir la eliminaciÃ³n de contactos.
Mostrar tooltips para mejorar la usabilidad.
Manejar la lÃ³gica de filtrado por categorÃ­a y la bÃºsqueda.
4. NewContactModal.vue
Este es un componente modal con un formulario. Su Ãºnica funciÃ³n es permitir a los usuarios crear un nuevo contacto desde cero que no exista en la guÃ­a pÃºblica. Se encarga de la validaciÃ³n del formulario y de enviar los datos al store de Pinia para que sean guardados en el backend.
5. ContactDetailsModal.vue
Otro componente modal, pero este es mucho mÃ¡s complejo. ActÃºa como el panel de control para la informaciÃ³n detallada de un contacto. Su funciÃ³n es:
Mostrar y permitir la ediciÃ³n de detalles personales (cargo, empresa, direcciÃ³n, etc.).
Integrar otros microcomponentes para gestionar informaciÃ³n especÃ­fica.
6. ContactInfoEditor.vue
Un componente especializado diseÃ±ado para manejar los telÃ©fonos y correos electrÃ³nicos de un contacto. Se encarga de:
Listar los telÃ©fonos y correos existentes.
Proporcionar campos para aÃ±adir, editar y eliminar entradas.
Validar el formato del correo electrÃ³nico.
7. FollowupEvents.vue
Este componente se encarga de la gestiÃ³n de eventos de seguimiento. Muestra un historial de interacciones pasadas y permite al usuario registrar nuevas interacciones o eventos de seguimiento futuros.
8. ContactCategories.vue
Finalmente, este componente gestiona las categorÃ­as o etiquetas de un contacto. Su funciÃ³n es permitir al usuario asociar un contacto a una o varias categorÃ­as predefinidas, o incluso crear nuevas categorÃ­as sobre la marcha.
Al dividir la interfaz de usuario en estos microcomponentes, logramos una estructura modular y mantenible. Cada componente tiene una responsabilidad clara, lo que hace que el cÃ³digo sea mÃ¡s fÃ¡cil de entender, depurar y escalar en el futuro.
-------------

TABLAS RESUMEN.
Tabla: general - Campos: id, nombres, apellidos, completo, cedula
Tabla: telefonos - Campos: id, cedula_persona, numero, tipo, id_usuario
Tabla: user_agendas - Campos: user_id, contact_cedula, created_at, updated_at, tipo_relacion
Tabla: user_nombres - Campos: user_id, contact_cedula, nombre_personalizado
Tabla: user_telefonos - Campos: id, user_id, contact_cedula, numero, tipo
Tabla: contact_details - Campos: cedula, cargo, empresa, direccion, notas, fecha_nacimiento, es_padre, es_madre, created_at, updated_at, perfil_linkedin, area_negocio, user_id
Tabla: contact_notes - Campos: id, user_id, contact_cedula, titulo, cuerpo, fecha_nota
Tabla: follow_up_events - Campos: id, user_id, title, description, date, color, icon, created_at, updated_at, contact_cedula, event_key, contexto_interaccion, es_recordatorio
Tabla: categorias - Campos: id, nombre_categoria
Tabla: user_agenda_categorias - Campos: user_id, contact_cedula, categoria_id

INDEXES RESUMEN.
general_pkey: PRIMARY KEY on id 
idx_general_apellidos: BTREE index on apellidos
idx_general_cedula: BTREE index on cedula
idx_general_nombres: BTREE index on nombres
idx_general_search_vector: GIN index on search_vector
unique_cedula_constraint: UNIQUE CONSTRAINT on cedula
telefonos_pkey: PRIMARY KEY on id
idx_telefonos_cedula: BTREE index on cedula_persona
idx_telefonos_numero: BTREE index on numero
user_agendas_pkey: PRIMARY KEY on (user_id, contact_cedula)
idx_user_agendas_tipo_relacion: BTREE index on tipo_relacion
user_nombres_pkey: PRIMARY KEY on (user_id, contact_cedula)
user_telefonos_pkey: PRIMARY KEY on id
contact_details_pkey: PRIMARY KEY on (user_id, cedula)
idx_contact_details_area_negocio: BTREE index on area_negocio
contact_notes_pkey: PRIMARY KEY on id
follow_up_events_pkey: PRIMARY KEY on id
follow_up_events_event_key_key: UNIQUE CONSTRAINT on event_key
idx_follow_up_events_contact_cedula: BTREE index on contact_cedula
categorias_pkey: PRIMARY KEY on id
categorias_nombre_categoria_key: UNIQUE CONSTRAINT on nombre_categoria
user_agenda_categorias_pkey: PRIMARY KEY on (user_id, contact_cedula, categoria_id)
idx_user_agenda_categorias_categoria_id: BTREE index on categoria_id
idx_user_agenda_categorias_user_id: BTREE index on user_id

FOREIGN KEY RESUMEN
fk_general_created_by: La columna created_by hace referencia a la columna id de la tabla users.
fk_general_updated_by: La columna updated_by hace referencia a la columna id de la tabla users.
telefonos_cedula_persona_fkey: La columna cedula_persona hace referencia a la columna cedula de la tabla general.
fk_user_agenda_contact: La columna contact_cedula hace referencia a la columna cedula de la tabla general.
fk_user_agenda_user: La columna user_id hace referencia a la columna id de la tabla users.
fk_user_nombres: Las columnas (user_id, contact_cedula) hacen referencia a las columnas (user_id, contact_cedula) de la tabla user_agendas.
fk_user_telefonos: Las columnas (user_id, contact_cedula) hacen referencia a las columnas (user_id, contact_cedula) de la tabla user_agendas.
fk_cedula_contact_general: La columna cedula hace referencia a la columna cedula de la tabla general.
fk_user_contact_details: Las columnas (user_id, cedula) hacen referencia a las columnas (user_id, contact_cedula) de la tabla user_agendas.
fk_contact_notes: Las columnas (user_id, contact_cedula) hacen referencia a las columnas (user_id, contact_cedula) de la tabla user_agendas.
fk_follow_up_event_contact: Las columnas (user_id, contact_cedula) hacen referencia a las columnas (user_id, contact_cedula) de la tabla user_agendas.
follow_up_events_user_id_fkey: La columna user_id hace referencia a la columna id de la tabla users.
fk_user_agenda_categorias_categoria: La columna categoria_id hace referencia a la columna id de la tabla categorias.
fk_user_agenda_categorias_user: Las columnas (user_id, contact_cedula) hacen referencia a las columnas (user_id, contact_cedula) de la tabla user_agendas.

REFERENCES RESUMEN
A general: abogados, contact_details, despachantes,docentes,func_bnf,funcpublic,itaipu,user_agendas,yacyreta,telefonos,telefonos_historial
A user_agendas: contact_notes, follow_up_events, user_agenda_categorias, contact_details,user_nombres, user_telefonos
A categorias: user_agenda_categorias