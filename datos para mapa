un momento... vamos a analizar toda la columna de datos posibles..
----
https://www.catastro.gov.py/visor/?visor=geomajas&dpto=B&dist=1&padron=9468
----
https://www.catastro.gov.py/geoserver/gwc/service/wms?SERVICE=WMS&VERSION=1.1.1&REQUEST=GetMap&FORMAT=image%2Fpng&TRANSPARENT=true&LAYERS=snc%3Aparcelas_activas&TILED=true&SRS=EPSG%3A32721&WIDTH=256&HEIGHT=256&STYLES=&BBOX=-81999.515%2C6947871.076%2C377088.7112499998%2C7406959.30225
----
SERVICE
WMS
VERSION
1.1.1
REQUEST
GetMap
FORMAT
image/png
TRANSPARENT
true
LAYERS
snc:parcelas_activas
TILED
true
SRS
EPSG:32721
WIDTH
256
HEIGHT
256
STYLES
BBOX
-81999.515,6947871.076,377088.7112499998,7406959.30225
----
Mapa.js:117 (4) [-933763.9900275782, 6470517.72857216, 937763.0200275782, 8129482.27142784]0: -933763.99002757821: 6470517.728572162: 937763.02002757823: 8129482.27142784length: 4[[Prototype]]: Array(0)at: ƒ at()concat: ƒ concat()constructor: ƒ Array()copyWithin: ƒ copyWithin()entries: ƒ entries()every: ƒ every()fill: ƒ fill()filter: ƒ filter()find: ƒ find()findIndex: ƒ findIndex()findLast: ƒ findLast()findLastIndex: ƒ findLastIndex()flat: ƒ flat()flatMap: ƒ flatMap()forEach: ƒ forEach()includes: ƒ includes()indexOf: ƒ indexOf()join: ƒ join()keys: ƒ keys()lastIndexOf: ƒ lastIndexOf()length: 0map: ƒ map()pop: ƒ pop()push: ƒ push()reduce: ƒ reduce()reduceRight: ƒ reduceRight()reverse: ƒ reverse()shift: ƒ shift()slice: ƒ slice()some: ƒ some()sort: ƒ sort()splice: ƒ splice()toLocaleString: ƒ toLocaleString()toReversed: ƒ toReversed()toSorted: ƒ toSorted()toSpliced: ƒ toSpliced()toString: ƒ toString()unshift: ƒ unshift()values: ƒ values()with: ƒ with()Symbol(Symbol.iterator): ƒ values()Symbol(Symbol.unscopables): {at: true, copyWithin: true, entries: true, fill: true, find: true, …}[[Prototype]]: Object
visor/?visor=geomajas&dpto=B&dist=1&padron=9468:1  GET https://www.catastro.gov.py/manifest.json 404 (Not Found)
visor/?visor=geomajas&dpto=B&dist=1&padron=9468:1 Manifest fetch from https://www.catastro.gov.py/manifest.json failed, code 404
manifest.json:1  GET https://www.catastro.gov.py/manifest.json 404 (Not Found)
visor/?visor=geomajas&dpto=B&dist=1&padron=9468:1 Manifest fetch from https://www.catastro.gov.py/manifest.json failed, code 404
manifest.json:1  GET https://www.catastro.gov.py/manifest.json 404 (Not Found)
visor/?visor=geomajas&dpto=B&dist=1&padron=9468:1 Manifest fetch from https://www.catastro.gov.py/manifest.json failed, code 404
-----
(4) [-933763.9900275782, 6470517.72857216, 937763.0200275782, 8129482.27142784]
0
:
-933763.9900275782
1
:
6470517.72857216
2
:
937763.0200275782
3
:
8129482.27142784
----
----
{
    "type": "FeatureCollection",
    "features": [
        {
            "type": "Feature",
            "id": "parcelas_activas.1635441",
            "geometry": {
                "type": "Polygon",
                "coordinates": [
                    [
                        [
                            458313.023,
                            7411379.0575
                        ],
                        [
                            458268.203,
                            7410594.379
                        ],
                        [
                            458392.741,
                            7410580.0555
                        ],
                        [
                            458461.2025,
                            7411389.806
                        ],
                        [
                            458313.023,
                            7411379.0575
                        ]
                    ]
                ]
            },
            "geometry_name": "tmp_shape",
            "properties": {
                "id": 1635441,
                "objectid": 8078791,
                "id_parcela": 8078791,
                "dpto": "B",
                "dist": 1,
                "padron": 9468,
                "zona": null,
                "mz": null,
                "lote": null,
                "finca": 576,
                "nro_matricula": null,
                "ccatastral": "B01000009468",
                "obs": " ",
                "mz_agr": null,
                "lote_agr": null,
                "tipo_pavim": null,
                "tipo_cuenta": 0,
                "hectareas": 10,
                "superficie_tierra": 8809,
                "superficie_edificado": null,
                "valor_tierra": 0,
                "valor_edificado": null,
                "shape": {
                    "type": "MultiPolygon",
                    "coordinates": [
                        [
                            [
                                [
                                    458313.023,
                                    7411379.0575
                                ],
                                [
                                    458268.203,
                                    7410594.379
                                ],
                                [
                                    458392.741,
                                    7410580.0555
                                ],
                                [
                                    458461.2025,
                                    7411389.806
                                ],
                                [
                                    458313.023,
                                    7411379.0575
                                ]
                            ]
                        ]
                    ]
                },
                "tipo": null,
                "referencia": 0
            },
            "bbox": [
                458268.203,
                7410580.0555,
                458461.2025,
                7411389.806
            ]
        }
    ],
    "totalFeatures": 1,
    "numberMatched": 1,
    "numberReturned": 1,
    "timeStamp": "2025-09-16T19:33:17.250Z",
    "crs": {
        "type": "name",
        "properties": {
            "name": "urn:ogc:def:crs:EPSG::32721"
        }
    },
    "bbox": [
        458268.203,
        7410580.0555,
        458461.2025,
        7411389.806
    ]
}
-----
https://www.catastro.gov.py/geoserver/ows?service=WFS&version=1.1.0&request=GetFeature&outputFormat=application/json&srsname=EPSG:32721&typename=snc:parcelas_activas&CQL_FILTER=dist=1%20AND%20dpto=%27B%27%20AND%20padron=%279468%27&
----
import axios from 'axios';
const fetchPropertyGeometry = async (dpto, dist, padron) => {
  try {
    // URL base del servicio WFS
    const baseUrl = 'https://www.catastro.gov.py/geoserver/ows';
    // Construir el filtro para la consulta
    const cqlFilter = `dist=${dist} AND dpto='${dpto}' AND padron='${padron}'`;
    // Parámetros de la petición WFS
    const params = {
      service: 'WFS',
      version: '1.1.0',
      request: 'GetFeature',
      outputFormat: 'application/json',
      srsname: 'EPSG:32721', // Sistema de referencia de coordenadas
      typename: 'snc:parcelas_activas',
      CQL_FILTER: cqlFilter,
    };
    // Realizar la petición
    const response = await axios.get(baseUrl, { params });
    // La respuesta es un objeto GeoJSON
    const geoJsonData = response.data;
    // Retorna la geometría para usarla en el mapa
    if (geoJsonData.features.length > 0) {
      return geoJsonData.features[0].geometry;
    }
    return null;
  } catch (error) {
    console.error("Error al obtener la geometría:", error);
    return null;
  }
};
-----
gemini esto es la primera pieza del rompe cabezas..
aun necesitamos - la guia de como obtener los datos de de las propiedades URBANA... para presentar en el mapa..
--------------
otro analisis necesario es como persistir todos los datos de mapas en nuestra aplicacion... pensar en un diseño de tabla ideal para estos datos.. ya poseo postgis para tener una base de datos optimizada para datos geo..
-----
el motivo de la persistencia es que la api es muy intermitente... los que ya se consultaron y tengan datos geográficos almacenaremos..., para ir poco a poco dejar de terner una dependencia del mapa de la api catastral... pero esto es progresivo..
----
deseo utilizar openlayer para poder incrustar informaciones personalizadas como iconos y metadatos... eso será posible..
---
buscar un layer con imagenes satelitales reales.....
para dar mas impacto a la aplicacion... si es que existen... tratar a lo maximo emular al google maps... utilizando todas las librerías gratuitas posibles para este fin...
----
acepto tada recomendación.
a saber si es posible LA IDEA...
----
===========================================
1. Obtener Datos de Propiedades Urbanas
Como bien intuyes, la clave es usar la misma petición WFS que ya descubriste, pero con un filtro diferente. El servicio WFS (snc:parcelas_activas) contiene tanto propiedades rurales como urbanas. Para diferenciarlas, la API utiliza un campo que probablemente indica el tipo de propiedad.
Hipótesis y Guía de Acción:
Revisa el JSON del WFS: En el GeoJSON que capturaste anteriormente, buscamos un campo que se relacione con "tipo" o "naturaleza" de la propiedad. Hay un campo llamado "tipo_cuenta".
Consulta la API: Es probable que un valor específico en este campo (0, 1, Urbana, etc.) diferencie las parcelas urbanas. Puedes probar a modificar tu filtro CQL para incluir este campo.
Ejemplo de Petición WFS para Propiedades Urbanas:
Si la API usa un campo llamado tipo_propiedad con valor 'urbana', el filtro sería:
JavaScript
const cqlFilter = `tipo_propiedad='urbana' AND dpto='${dpto}' AND dist=${dist} AND padron='${padron}'`;
Si la API usa un código numérico para el tipo de cuenta, como "tipo_cuenta": 1, el filtro sería:
JavaScript
const cqlFilter = `tipo_cuenta=1 AND dpto='${dpto}' AND dist=${dist} AND padron='${padron}'`;
Recomendación: Confirma el campo y su valor exacto para propiedades urbanas haciendo una nueva inspección de la red en el navegador, buscando una propiedad urbana en el visor y analizando su JSON.
2. Persistencia de Datos con PostGIS
Tu idea de usar PostGIS es la solución profesional para manejar la intermitencia de la API. Aquí está el diseño de tabla ideal, expandido para incluir los datos que obtendrías de ambas APIs (la de cuenta-rural y la WFS).
SQL
CREATE TABLE IF NOT EXISTS parcelas_catastro (
    id_unico SERIAL PRIMARY KEY,
    -- Identificadores de la propiedad
    dpto VARCHAR(10) NOT NULL,
    distrito INTEGER NOT NULL,
    padron VARCHAR(255) NOT NULL,
    tipo_propiedad VARCHAR(50) NOT NULL, -- 'rural' o 'urbana'
    -- Datos descriptivos de la API de 'cuenta-rural'
    finca VARCHAR(255),
    propietario TEXT,
    cedula TEXT,
    telefono TEXT,
    hectareas DECIMAL,
    metros_cuadrados DECIMAL,
    valor_oficial DECIMAL,
    -- Datos de la geometría de la API WFS
    -- La columna GEOMETRY para el polígono de la parcela (MultiPolygon)
    geom GEOMETRY(MultiPolygon, 32721),
    -- Metadatos para gestionar la persistencia y la obsolescencia de los datos
    fecha_consulta TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    origen VARCHAR(50) DEFAULT 'API' -- O 'manual' si se carga de otra forma
);
-- Índices para optimizar las consultas
CREATE UNIQUE INDEX idx_unique_propiedad ON parcelas_catastro (dpto, distrito, padron);
CREATE INDEX idx_parcelas_catastro_geom ON parcelas_catastro USING GIST(geom);
Estrategia de Almacenamiento:
Cuando el usuario busque una propiedad, primero consulta esta tabla. Si la propiedad no existe, haces la consulta a la API de Catastro y luego insertas todos los datos (descriptivos y la geometría) en esta tabla. A partir de la segunda consulta, ya no necesitarás llamar a la API externa.
3. OpenLayers para Personalización
Sí, es totalmente posible y, de hecho, OpenLayers es la herramienta perfecta para tu objetivo.
Iconos y Marcadores: Puedes usar la capa vectorial (ol/layer/Vector) para agregar marcadores con iconos personalizados (ol/style/Icon) en las ubicaciones que necesites, por ejemplo, el centroide de una parcela.
Dibujar Geometrías: OpenLayers puede leer directamente el objeto GeoJSON que obtienes del servicio WFS. Puedes usar una fuente de datos (ol/source/Vector) para cargar el polígono de la parcela y pintarlo en el mapa con tu propio estilo (ol/style/Style), como un borde más grueso o un relleno transparente.
Metadatos en Popups: Puedes crear eventos al hacer clic en un polígono o un marcador para mostrar una ventana emergente (popup) con toda la información detallada que ya tienes en tu base de datos (propietario, hectáreas, etc.).
4. Capas Satelitales Gratuitas
Sí, existen varias opciones de capas satelitales de alta calidad y gratuitas que puedes usar para emular a Google Maps. Son servicios de "teselas" (tile layers) que se integran fácilmente en OpenLayers.
Recomendaciones:
ESRI World Imagery: Una de las mejores opciones gratuitas y de alta resolución.
URL de la capa: https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}
Google Satellite (a través de servicios no oficiales): Hay algunos servicios proxy que te permiten usar las teselas de Google Maps, aunque es importante verificar si su uso es compatible con tu proyecto.
CartoDB Dark/Light Matter: Si quieres un mapa más estilizado para superponer tus datos, estas capas son excelentes. No son satelitales, pero son muy visuales y gratuitas.
Bing Maps Satelite: Requiere una clave de API, pero la capa de satélite es de muy buena calidad.
Cómo agregarlo en OpenLayers:
JavaScript
import TileLayer from 'ol/layer/Tile';
import XYZ from 'ol/source/XYZ';
// Capa de imágenes satelitales de ESRI
const esriSatelliteLayer = new TileLayer({
  source: new XYZ({
    url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
    attributions: 'Powered by <a href="https://www.esri.com/">Esri</a>'
  })
});
// Luego, añade esta capa a tu mapa:
map.addLayer(esriSatelliteLayer);
Resumen:
Tu plan es totalmente viable. Tienes las herramientas, el enfoque correcto y ahora una guía detallada para unir todas las piezas. Puedes avanzar con confianza, sabiendo que estás construyendo una aplicación moderna y escalable.
----
---
Sí, ¡definitivamente! Esri World Imagery es la mejor opción para un proyecto como el tuyo.
Es un estándar de la industria por una razón: su alta calidad, cobertura global y actualizaciones constantes lo convierten en el fondo perfecto para superponer tus datos georreferenciados. Es el equivalente gratuito y de alto rendimiento a lo que verías en Google Maps o Bing.
Aquí está el fragmento de código final para tu proyecto, listo para ser implementado.
Integración en tu Mapa con OpenLayers
Para añadir la capa de Esri World Imagery a tu mapa, simplemente agrega este código a la inicialización de tu mapa en tu componente Vue.
JavaScript
import Map from 'ol/Map';
import View from 'ol/View';
import TileLayer from 'ol/layer/Tile';
import XYZ from 'ol/source/XYZ';
// Define la capa de imágenes satelitales de Esri
const esriSatelliteLayer = new TileLayer({
  source: new XYZ({
    url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
    attributions: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, swisstopo, and the GIS User Community'
  })
});
// Inicializa tu mapa y añade la capa
const map = new Map({
  target: 'map-container', // El id de tu elemento HTML
  layers: [
    esriSatelliteLayer, // Añade la capa satelital primero
    // Aquí irían tus otras capas vectoriales (polígonos de parcelas)
  ],
  view: new View({
    center: [0, 0], // El centro inicial del mapa
    zoom: 2, // El nivel de zoom inicial
    projection: 'EPSG:32721' // Asegúrate de usar la proyección correcta
  }),
});
Con esta pieza final, tienes todo lo necesario para construir una aplicación profesional, escalable y con un gran impacto visual.
-------------------
Excelente. Has capturado la esencia del problema y la solución en un solo plan. La lógica que propones es la forma más profesional y robusta de construir una aplicación que combine datos en tiempo real con una base de datos persistente.
Vamos a establecer un plan de acción para el front-end, integrando todos los componentes que hemos discutido.
Plan de Acción para Potenciar tu Mapa
Tu componente de búsqueda avanzada será el núcleo de esta lógica. El flujo de trabajo se dividirá en tres fases clave:
Fase 1: Búsqueda y Obtención de Datos en Paralelo
Tu función de búsqueda debe ser optimizada para manejar múltiples propiedades a la vez y obtener su información de forma asíncrona.
Busca en tu Fuente Principal: Primero, tu v-data-table-server realiza una consulta a tu propia base de datos (o a la API de listado general) para obtener una lista de propiedades filtradas por departamento, ciudad, etc. Esta consulta te dará el padrón de cada propiedad.
Iteración y Consultas Paralelas: Con la lista de padrones, inicia un proceso asíncrono para cada uno. Para cada propiedad en la lista, lanza dos consultas simultáneas:
API 1 (Datos Descriptivos): Llama a la API de cuenta-rural para obtener el propietario, cédula, etc.
API 2 (Datos Georeferenciados): Llama a la API WFS que descubriste para obtener la geometría (el polígono) de la parcela.
Procesamiento Inteligente: Utiliza una función como Promise.all() en JavaScript para esperar que todas las peticiones terminen. Esto hará que la carga de datos sea mucho más rápida que si las consultas se hicieran una por una.
Fase 2: Filtrado Inteligente para el Mapa
Una vez que todas las peticiones han finalizado, procesa los resultados antes de pasarlos al mapa.
Filtra los Datos: Crea una nueva variable (por ejemplo, mapProperties). Recorre la lista de resultados y, para cada propiedad, verifica si la llamada a la API WFS fue exitosa y si devolvió una geometría válida.
Población del Mapa: Si una propiedad tiene datos georeferenciados, agrega un objeto a tu array mapProperties que contenga:
La geometría (el polígono GeoJSON).
Los datos descriptivos (padrón, propietario, etc.).
Actualización del Componente: Pasa este array mapProperties a tu MapComponent. Esto asegura que el mapa solo dibuje las 15 parcelas que tienen información georeferenciada.
Fase 3: Persistencia y Optimización Progresiva
Este es el paso más importante para lograr la independencia de la API.
Lógica de Caché: Antes de hacer la llamada a la API WFS, tu aplicación debe hacer una consulta a tu base de datos PostGIS.
if (base_de_datos.getGeometria(padron) === null): Si no tienes la geometría, haz la llamada a la API WFS.
else: Si la geometría ya está almacenada, úsala directamente.
Guardar los Datos: Si la llamada a la API WFS es exitosa y obtienes la geometría, envía estos datos a un endpoint de tu backend (/api/guardar-geometria). Este endpoint se encargará de insertar o actualizar la geometría y los datos descriptivos de la propiedad en tu tabla de PostGIS.
Resumen del Flujo de Datos
Fragmento de código
graph TD
    subgraph Frontend
        A[Búsqueda Avanzada] --> B{Propiedades Filtradas?};
        B -- Sí --> C[Obtener Padrones];
    end
    subgraph Lógica de Búsqueda
        C --> D{Geometría en la BD?};
        D -- No --> E{Llamada a API WFS};
        D -- Sí --> G[Usar GeoJSON de la BD];
        E --> F{Respuesta Válida?};
        F -- Sí --> H[Guardar en BD];
        H --> G;
        F -- No --> I[Mapeable = Falso];
    end
    subgraph Frontend
        C --> J{Llamada a API Catastro para Detalles};
        J --> K[Obtener Propietario/Cédula];
    end
    subgraph Componentes de la App
        G & K --> L[Unir Datos];
        L --> M{Es Mapeable?};
        M -- Sí --> N[Añadir a Array 'mapProperties'];
        M -- No --> O[Ignorar];
        N --> P[Renderizar Mapa];
    end
Este plan te asegura que cada vez que una propiedad se consulte, su información geográfica se guardará de forma segura. Con el tiempo, tu base de datos se llenará de datos georreferenciados, reduciendo drásticamente la necesidad de depender de la API de catastro para las búsquedas más comunes.
Hoja de Ruta: De la Búsqueda al Mapa
Configurar el Backend para la Persistencia:
Crea un nuevo endpoint en tu backend (ej. /api/guardar-propiedad).
Este endpoint debe aceptar un POST con los datos de una propiedad, incluyendo su geometría en formato GeoJSON.
La lógica de este endpoint debe insertar o actualizar la propiedad en tu tabla de PostGIS.
Modificar la Función de Búsqueda del Front-end:
Ve a tu función handleSearch en el componente de búsqueda.
Después de obtener la lista de propiedades de la consulta inicial, inicia un bucle sobre cada una de ellas.
Dentro del bucle, haz una consulta a tu backend (ej. /api/obtener-geometria?padron=...) para ver si la geometría de la propiedad ya está en tu base de datos.
Implementar la Lógica de Caché y API:
Si la respuesta de tu backend es negativa (la geometría no existe), haz dos llamadas simultáneas:
Una a la API de Catastro para los datos de propietario.
Otra a la API WFS para obtener la geometría.
Cuando la llamada a la API WFS sea exitosa, toma el GeoJSON y envíalo a tu endpoint de backend que creaste en el paso 1 para guardarlo.
Crear el Array de Propiedades "Mapeables":
Crea un array vacío, por ejemplo, mappableProperties = [].
Al recibir los datos de cada propiedad (ya sea de tu base de datos o de la API), verifica si el objeto de geometría (geometry) existe y es válido.
Si la geometría existe, agrega toda la información de la propiedad a este array mappableProperties.
Actualizar y Renderizar el Mapa:
Al final de la función de búsqueda, después de haber procesado todas las propiedades, pasa el array mappableProperties a tu MapComponent.
Modifica tu MapComponent para que, en lugar de renderizar marcadores, dibuje las formas (polígonos) utilizando los datos GeoJSON de cada propiedad en el array.
Sigue estos pasos en orden, y tu aplicación será capaz de buscar, obtener y mostrar inteligentemente solo las propiedades con datos geográficos, mientras construye progresivamente su propia base de datos de mapas.
----
la verdad que es un link de arcgis.com para saber si podemos usar para saber si podemos usar world imagery con open layer como vista mapa principal para nuestra apliacion o no es posible..
----
----- IMPLEMENTACIÓN...

Paso 1: Configurar la Base de Datos ⚙️

Este es el punto de partida. Necesitas crear una nueva tabla que será el pilar de toda la funcionalidad del mapa.
Crea la Tabla propiedades_geo: Esta tabla almacenará los polígonos (la forma de la parcela) de las propiedades que ya has consultado. Su diseño debe ser simple y eficiente.
id: Clave primaria, tipo entero, autoincremental.
id_vinculo: Entero. Esta es la clave de todo. Este campo debe coincidir con el id o id_vinculo de la propiedad en tu tabla principal (propiedades_propietarios). Así, sabrás a qué propiedad pertenece cada polígono.
geojson: Texto (TEXT) o JSON. Aquí guardarás el polígono en formato GeoJSON. El tipo de dato JSON es ideal para esto.
fecha_creacion: Sello de tiempo (TIMESTAMP) con la fecha y hora de la inserción.
Paso 2: Crear la Lógica del Backend (API) 🖥️
Tu backend será el cerebro que gestiona las peticiones a la API externa de Catastro y a tu nueva tabla local.
Nueva Ruta de Búsqueda Principal (GET /api/propiedades/buscar): En lugar de modificar tu ruta actual, crea una nueva que esté optimizada para el frontend. Esta ruta es la que alimentará tu tabla de resultados.
Función: Aceptará los filtros de búsqueda (departamento, ciudad, etc.).
Lógica: En tu consulta SQL, haz un LEFT JOIN con la tabla propiedades_geo.
Resultado: Devolverá una lista de propiedades, y cada registro tendrá una nueva columna booleana, por ejemplo, tiene_mapa, que será true si la propiedad existe en propiedades_geo y false si no.
Nueva Ruta de Enriquecimiento (POST /api/propiedades/enriquecer): Esta es la ruta central que manejará toda la lógica compleja.
Función: Recibirá el id_vinculo de la propiedad que el usuario quiere enriquecer.
Lógica:
a.  Realizará una petición a la API de Catastro para obtener los datos de propietarios.
b.  Guardará esos datos en tu tabla propiedades_propietarios (o los actualizará si ya existen).
c.  Realizará una segunda petición al servicio WFS de Catastro para obtener los datos geoespaciales (el polígono).
d.  Guardará esos datos en tu nueva tabla propiedades_geo.
Importante: Esta ruta es crítica. Debe ser robusta y manejar los posibles errores de la API externa.
Nueva Ruta de Consulta del Mapa (GET /api/propiedades/geo/:id_vinculo): Esta ruta es para cuando el usuario hace clic en el ícono del mapa.
Función: Aceptará un id_vinculo como parámetro.
Lógica: Realizará una consulta directa y simple a tu tabla propiedades_geo y devolverá el geojson de ese registro. Esta petición debe ser extremadamente rápida, ya que no depende de ningún servicio externo.
Paso 3: Construir el Frontend (Vue y Pinia) 🌐
Aquí es donde el usuario interactúa con tu sistema.
Modifica tu Store de Pinia:
Estado (State):
propiedades: La lista de propiedades que se mostrará en la tabla.
mapProperties: Un arreglo para guardar los datos geoespaciales que se le pasarán al componente del mapa.
showMapModal: Una variable booleana para controlar si el modal del mapa está abierto.
Acciones (Actions):
fetchPropiedades(filtros): Tu acción de búsqueda que ahora llama a la nueva ruta GET /api/propiedades/buscar.
enriquecerPropiedad(item): Llamará a la ruta POST /api/propiedades/enriquecer. Una vez que la llamada sea exitosa, actualizará el item en el estado propiedades para que item.tiene_mapa sea true. Esto es clave para el cambio visual.
verMapa(id_vinculo): Llamará a la ruta GET /api/propiedades/geo/:id_vinculo para obtener el GeoJSON. Luego, guardará ese GeoJSON en la variable de estado mapProperties y establecerá showMapModal en true.
Modifica tu Componente de Vue (La Tabla de Resultados):
Estructura de la Tabla: Añade una columna para las acciones.
Lógica Condicional: Dentro de la celda de acciones, usa la directiva v-if para mostrar lo siguiente:
v-if="!item.tiene_mapa": Muestra el botón de "Buscar en Catastro". Al hacer clic, llama a la acción enriquecerPropiedad.
v-else: Muestra el ícono de mapa. Al hacer clic, llama a la acción verMapa.
Componente del Mapa: Crea un modal o un componente separado para mostrar el mapa. Este componente recibirá los datos de mapProperties de tu store.
Este plan te da una hoja de ruta completa, desde la base de datos hasta la interfaz de usuario, para construir la funcionalidad de forma lógica y eficiente.
